{"hash":"87002c5fa157b6e786d19711f6bffff4b0d9c799","data":{"data":{"id":"10","title":"前端工程化3：如何编写一个Nodejs Cli应用/自定义脚手架","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"## 什么是Nodejs Cli应用？\n简单来说就是在命令行可以使用nodejs来执行的应用，例如：vue-cli、creat-react-app、webpack-cli等；在前端开发过程中我们会用到很多的工具，这些工具在安装过后可以直接使用命令行执行；注意在全局安装和在项目安装不同。\n```\n// 全局安装，直接执行命令\n> npm install webpack webpack-cli -g\n> webpack\n\n// 项目安装，需要借助npx执行\n> npm install webpack webpack-cli --save-dev\n> npx webpack\n```\n\n## Nodejs Cli应用的工作流程！\n\n**1、启动过程：**\n\n命令行执行命令 => 根据package.json中bin查询入口 => 执行入口js文件cli.js\n\n**2、执行过程：**\n\n命令行执行js文件功能启动=> 命令行询问用户问题 => 结合问题答案+模板等文件 => 生成结构文件\n\n\n## Nodejs Cli应用的入口文件：cli.js\n\n **1、入口文件路径** ，首先在package.json 中添加bin字段\n```js\n{\n  \"name\": \"ncl\",\n  \"main\": \"index.js\",\n  \"bin\": {\n    \"ncl\": \"./cli.js\"   //入口文件，ncl和name保持一致\n  },\n  ...\n}\n```\n\n **2、入口文件特定的文件头** ，在cli.js顶部输入\n```js\n#!/usr/bin/env node\n```\n\n **3、入口文件权限** \n// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755\n// 具体就是通过 chmod 755 cli.js 实现修改\n\n **4、简单测试模块** \nnpm link 可以将模块链接到全局，也可以链接到使用该模块的项目node_modules中；这样在开发模块的过程中，不用发布到npm也可以使用模块进行测试。\n```js\n> npm link // 在自定义模块项目的目录执行，将模块连接到全局\n> ncl // 直接执行模块，使用模块名\n```\n\n## Nodejs Cli应用的示例\n该示例的功能实现一个自定义的脚手架：在命令行询问用户一些简单的问题作为参数，然后自动生成一些项目文件。其中的文件可以通过模板生成，也可以传递数据到模板。\n![image.png](/img/bVcS16g)\n\n **1、安装一些依赖模块** \n```js\n> npm install inquirer --save //nodejs环境下，实现命令行的用户交互插件 \n> npm install ejs --save //模板引擎\n```\n\n **2、cli.js中定义命令行询问用户问题**\n- inquire.prompt进行命令行的用户询问操作\n- inquirer.prompt返回值为一个promise对象\n- inquirer.prompt的参数为一个数组\n\n```js\nconst inquirer = require('inquirer')\n\ninquirer.prompt([\n    {\n        type: 'input',\n        name: 'name',\n        message: '请输入项目名称?'\n    }\n])\n.then(anwsers => {\n    // anwsers: { name: \"xxx\" } //anwsers返回一个结果对象\n})\n```\n\n **3、获取模板目录和目标生成目录** \n\n```js\nconst path = require('path')\n\n\n// 模板目录\n// __dirname 获取当前执行代码文件的绝对路径\n// tmplDir 为templates的绝对路径\nconst tmplDir = path.join(__dirname, 'templates')\n\n// 目标目录\n// process.cwd()返回 Node.js 进程的当前工作目录。\n// process参考api文档：http://nodejs.cn/api/process.html\nconst destDir = process.cwd()\n```\n\n **4、模板引擎渲染模板** \n```js\nconst ejs = require('ejs')\nconst path = require('path')\n\n// 通过模板引擎渲染文件\n// 参数1：fileDir为文件的绝对路径\n// 参数2：渲染模板所需变量，存在anwsers对象里面\n// 参数3：回调函数，result为新文件\nejs.renderFile(fileDir, anwsers, (err, result) => {\n  if (err) throw err\n\n  // 将结果写入目标文件路径\n  fs.writeFileSync(fileDestDir, result)\n})\n```\n```\n// 一个package.json作为模板的示例：\n{\n\"name\": \"<%= name %>\",\n  \"version\": \"<%= version %>\",\n  \"description\": \"<%= description %>\",\n  \"author\": \"<%= author %>\",\n  \"bin\": \"cli.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"license\": \"ISC\"\n}\n\n```\n\n **5、读取目录下的文件** \n```js\n  // 将模板下的文件全部转换到目标目录\n  // 参数1：path\n  // 参数2：回调函数，参数files为文件相对路径组成的数组\n  fs.readdir(tmplDir, (err, files) => {\n    if (err) throw err\n    files.forEach(file => {\n      // 通过模板引擎渲染文件\n      // 处理 file \n      })\n    })\n  })\n\n```\n\n **6、将文件写入路径** \n```js\n// 将结果写入目标文件路径\n// 参数1：文件的绝对路径\n// 参数2：文件内容\nfs.writeFileSync(fileDestDir, result)\n```\n\n## 模板文件相关\n这里是根据自己的需求将需要自动生成的文件放到模板目录下，没有变化的或者统一的文件就不需要使用模板引擎。\n**1、模板路径：templates；**\n\n**2、通常将整理好的项目结构整体拷贝到templates下**，例如：vue的示例源文件、lint文件、package.json等等；\n![image.png](/img/bVcS16h)\n\n## 测试模块执行\n本地开发可以使用npm link关联模块目录和依赖此模块的项目node_modules目录；也可以发布到npm源上后直接安装使用模块。\n\n**1、关联模块：**\n```bash\n> cd nodejs-cli-sample //Nodejs Cli应用的目录\n> npm link // 将模块连接到全局\n```\n\n**2、执行模块：**\n```bash\n> cd nodejs-cli-demo // 在项目目录执行模块\n> ncl // 直接执行模块，使用模块名（ncl 是项目nodejs-cli-sample的名称）\n```\n\n## 发布Nodejs Cli应用\n1、可以直接使用npm publish发布到源上\n```bash\n> npm publish --registry=https://registry.xxxx\n```\n2、要考虑到npm源是否有写权限，可以发布到自己公司的npm源上或者yarn源上\n```\n// 淘宝镜像源是只读的，publish不上去\n// 发布到yarn的镜像源之后，使用淘宝镜像源时可以手动同步加快模块下载速度\nyarn publish --registry https://registry.yarnpkg.com/\n```\n\n## 完整示例代码\n**1、NodeJs Cli应用cli.js 入口文件**\n```js\n#!/usr/bin/env node\n\n\n// Node CLI 应用入口文件必须要有这样的文件头\n// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755\n// 具体就是通过 chmod 755 cli.js 实现修改\n\nconst fs = require('fs')    // 文件读写\nconst path = require('path')    // 路径获取\nconst inquirer = require('inquirer')    //命令行用户交互\nconst ejs = require('ejs')  // 模板引擎\n\n\n// 脚手架的工作过程：启动 => 命令行询问用户问题 => 结合问题答案+模板 => 生成结构文件\n\ninquirer.prompt([\n    {\n        type: 'input',\n        name: 'name',\n        message: '请输入项目名称(\\'\\')'\n    },\n    {\n        type: 'input',\n        name: 'version',\n        message: '请输入项目版本号(1.0.0)'\n    },\n    {\n        type: 'input',\n        name: 'description',\n        message: '请输入项目备注(\\'\\')'\n    },\n    {\n        type: 'input',\n        name: 'author',\n        message: '请输入作者名称(\\'\\')'\n    }\n])\n.then(anwsers => {\n    // anwsers: { name: \"xxx\" } //anwsers返回一个结果对象\n\n    // 模板目录绝对路径\n    const tmplDir = path.join(__dirname, 'templates')\n    // 目标目录\n    const destDir = process.cwd()\n\n    // 读取目录下所有文件\n    let readFiles = (dir) => {\n        return new Promise((resolve, reject)=>{\n            // 参数1：目录路径\n            // 参数2：回调函数（错误对象，files为文件相对路径组成的数组）\n            fs.readdir(dir, (err, files) => {\n                if (err) reject(err)\n                resolve(files)\n            })\n        })\n    }\n\n    // 处理模板文件\n    let ejsRender = (file) => {\n        return new Promise((resolve, reject)=>{\n            // 模板文件绝对路径\n            let dir = path.join(tmplDir, file)\n            // 参数1：文件路径\n            // 参数2：数据对象\n            // 参数3：回调函数（错误对象，渲染后的新文件）\n            ejs.renderFile(dir, anwsers, (err, result) => {\n                if (err) reject(err)\n                resolve(result)\n            })\n        })\n    }\n\n\n    // 1、先读取目录下所有文件\n    // 2、使用ejs渲染所有模板\n    // 3、再将新文件写到目标路径\n    readFiles(tmplDir).then((files)=>{\n        files.forEach(file => {\n            ejsRender(file).then((result)=>{\n                // 目标文件绝对路径，file其实是文件相对路径\n                let fileDestDir = path.join(destDir, file)\n                // 将结果写入目标文件路径\n                // 参数1：文件绝对路径\n                // 参数2：渲染后新文件\n                fs.writeFileSync(fileDestDir, result)\n            },throwError)\n        })\n\n    },throwError)\n})\n\n/**\n * 错误处理函数\n * @param {*错误对象} error \n */\nfunction throwError(error){\n    throw error\n}\n```\n\n**2、package.json 示例模板文件，使用的ejs模板引擎**\n```json\n{\n\"name\": \"<%= name %>\",\n  \"version\": \"<%= version %>\",\n  \"description\": \"<%= description %>\",\n  \"author\": \"<%= author %>\",\n  \"bin\": \"cli.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"license\": \"ISC\"\n}\n\n```\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)\n","published_at":"2021-07-11T15:03:08.830Z","updated_at":"2021-07-12T07:15:26.316Z"}},"context":{}}