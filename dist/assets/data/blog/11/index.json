{"hash":"87002c5fa157b6e786d19711f6bffff4b0d9c799","data":{"data":{"id":"11","title":"前端工程化4：如何去做js模块化开发？ES Modules/CommonJS有什么区别？","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"\n## 1. 如何去做js模块化开发 => 模块化标准 + 加载器\n1.1、我们说讨论的仅限于javascript代码的模块化，如果要涉及到所有文件的模块化请使用webpack。\n1.2、那么js的模块化可以用一句话概括：模块化标准 + 加载器；本文主要介绍模块化标准。\n \n## 2. 几种模块化标准对比：\n\n#### CommonJS\n1、以同步的模式加载模块：通常在Nodejs环境使用，不适合浏览器\n```\n1. 因为服务器读本地磁盘文件会比较快，所以nodejs的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；\n2. 如果在浏览器端代码执行时去同步require很多模块，也会影响页面执行效率。\n```\n2、一个文件就是一个模块，且每个模块都有单独的作用域；因为模块输出的是一个值的浅拷贝。\n3、require(模块)加载的是一个对象，该对象是运行时生成；\n4、导入导出\n```js\n// 导出\nmodule.exports = {\n    name: 'wangyi',\n    age: 18\n}\n\n// 导入\nconst { name, age } = require('./module.js')\n```\n\n#### ES Modules\n1、以异步的模式加载模块：支持Nodejs环境使用，也适合浏览器（ES6以上才支持的规范，存在兼容性问题，最好配合 webpack 进行加载）；\n2、ES Modules的导入导出是固定用法，输出的是值的只读引用（原始值变了，取值跟着变）；\n3、ES Modules的导入导出不是对象而是对外接口，该接口在代码编译时就完成，执行效率更高\n4、导入导出\n```js\n// 注意：此处是固定用法，export 后面不是对象；export default 后面才是对象\n\n// 导出1\nexport { name, age }\n// 导入1\nimport { name, age } from './module.js'\n\n// 导出2\nexport default { name, age }\n// 导入2\nimport module from './module.js'\nconst { name, age } = module\n```\n\n#### AMD + require.js\n1、以异步的方式加载模块，可以指定回调函数；\n2、AMD规范配合require.js库作为加载器使用；\n3、目前绝大多数第三方库都支持AMD\n4、使用起来比较复杂\n5、模块js文件请求频繁，因为每个模块都会创建一个script标签去请求文件\n6、导入导出\n```js\ndefine('module1', ['jquery', './module2'], function($, module2){\n  return {\n    // 可以在里面使用依赖的 $、module2 模块\n  }\n})\n```\n\n#### CMD + sea.js\nCMD规范配合sea.js库作为加载器使用，实现了模块化开发（淘宝）；后来sea.js被require.js兼容了，便不再使用。\n\n\n\n\n\n\n## 3. 模块化标准使用最佳实践\n#### 3.1、Nodejs环境 => CommonJS\n3.1.1、因为服务器读本地磁盘文件会比较快，所以 nodejs 的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；\n3.1.2、如果在浏览器端代码执行时去同步 require 很多模块，也会影响页面执行效率。\n3.1.3、module 对象是在 Nodejs环境定义的，配合 require 函数使用；如果说谁是 CommonJS 的加载器，那就是 Nodejs环境。\n\n#### 3.2、浏览器端 => ES Modules + Webpack\n3.2.1、因为浏览器端会有很多的异步加载且当前的ES6开发比较简单，所以浏览器端适合使用ES Modules。\n3.2.2、ES Modules 通常经过 webpack + babel 进行转换；将其转换成立即执行函数的方式，以此来模仿块级作用域；（webpack 也支持在源码中使用 CommonJS 和 ESM 互相导入导出，但一般不用）\n3.2.3、因为 webpack 是在 nodejs 环境运行，所以其配置文件通常使用 CommonJS 规范。\n3.2.4、因为 ES Modules 通常需要配合打包工具进行使用，所以 webpack 可以算得上它的加载器。\n\n\n## 4. ES Module 基本使用知识点\n\n **4.1、ES Modules虽然是ES6才出现的规范，但是未来浏览器原生支持**\n \n **4.2、ES Modules支持在script标签上直接定义使用：** \n4.2.1. ESM 自动采用严格模式，忽略 'use strict'\n4.2.2. 每个 ES Module 都是运行在单独的私有作用域中\n4.2.3. ESM 是通过 CORS 的方式请求外部 JS 模块的\n4.2.4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>ES Module - 模块的特性</title>\n</head>\n<body>\n  <!-- 通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 -->\n  <script type=\"module\">\n    console.log('this is es module')\n  </script>\n\n  <!-- 1. ESM 自动采用严格模式，忽略 'use strict' -->\n  <script type=\"module\">\n    console.log(this)\n  </script>\n\n  <!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 -->\n  <script type=\"module\">\n    var foo = 100\n    console.log(foo)\n  </script>\n  <script type=\"module\">\n    console.log(foo)\n  </script>\n\n  <!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的 -->\n  <!-- <script type=\"module\" src=\"https://unpkg.com/jquery@3.4.1/dist/jquery.min.js\"></script> -->\n\n  <!-- 4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果 -->\n  <script type=\"module\" src=\"demo.js\"></script>\n  <p>需要显示的内容</p>\n</body>\n</html>\n```\n\n **4.3、ES Modules 的 export和 import：** \n- 导出：\n - export { } 后面不是一个对象，而是固定用法 { XXX }，import { sss } from module也是固定用法，不是解构语法；export default { } 后面才可以跟一个对象、字符串等都行。\n - export 导出的是一个引用关系，而且是只读的！不是深拷贝的对象。\n\n```js\nvar name = 'foo module'\n\nfunction hello () {\n  console.log('hello')\n}\n\nclass Person {}\n\nexport { \n  name as foo, \n  hello, \n  Person \n}\n```\n\n- 导入（导入路径必须完整）：\n - 文件名称必须完整，不能省略.js、/index.js；\n - 相对路径也必须完整，不能省略./；\n - 可以绝对路径或者完整的url\n\n> import不支持动态导入，需要使用import().then()\n```js\nimport { foo, hello, Person } from './module.js'\nconsole.log(name, hello, Person)\n\n// 只加载模块不提取模块变量，可以简写：import './module.js'\nimport {} from './module.js'\nimport './module.js'\n\n// 导入模块内的全部变量\nimport * as mod from './module.js'\nconsole.log(mod)\n\n// 动态导入\nimport('./module.js').then(function (module) {\n  console.log(module)\n})\n```\n\n\n\n **4.4、ES Modules 的 export default**\n- export default 后面可以跟对象、字符串等类型\n- export 过后可以继续添加 export default \n- import 的第一个位置默认对应export default 导出的值\n\n```js\n// module.js\nvar name = 'jack'\nvar age = 18\n\nexport { name, age }\nconsole.log('module action')\nexport default 'default export'\n```\n\n```js\n// import.js\n// import { name, age, default as title } from './module.js'\n// abc 为 export default 导出值的重命名，abc 后面的 { } 不是对象解构，而是固定用法\n// import abc from './module.js'\nimport abc, { name, age } from './module.js'\nconsole.log(name, age, abc)\n```\n\n **4.5、ES Modules 的浏览器兼容**\nIE基本不兼容ES Modules\n\n插件 browser-es-module-loader 用于兼容ES Modules（开发阶段可用，不建议生产环境使用）\n1、在html中直接使用，参考：[npm官方地址](https://www.npmjs.com/package/browser-es-module-loader)\n\n```js\n// 该方法需要动态的去解析脚本执行ESM，性能差！只能在开发阶段使用。\n// script加上nomodule 属性，避免在支持ESM的浏览器上执行两次\n// babel-browser-build.js为babel的运行环境（浏览器端）\n<script nomodule src=\"dist/babel-browser-build.js\"></script>\n// ES Modules把代码读出来交给babel转换\n<script nomodule src=\"dist/browser-es-module-loader.js\"></script>\n \n<!-- script type=module loading -->\n<script nomodule  type=\"module\" src=\"path/to/module.js\"></script>\n\n...\n```\n\n2、npm中使用，估计还是作为依赖资源动态解析ESM（不建议使用）\n```\nnpm install browser-es-module-loader --save-dev\n```\n\n\n\n **4.6、ES Modules 的NodeJS支持情况（8.5+版本）**\nNodeJS 8.5以上的版本支持ES Modules，但是还是实验版本；\n```js\n// 第一，将文件的扩展名由 .js 改为 .mjs；（nodejs 12.10版本以上不需要修改文件名了）\n// 第二，启动时需要额外添加 `--experimental-modules` 参数；\n\nimport { foo, bar } from './module.mjs'\n\nconsole.log(foo, bar)\n\n// 此时我们也可以通过 esm 加载内置模块了\nimport fs from 'fs'\nfs.writeFileSync('./foo.txt', 'es module working')\n\n// 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员方式\nimport { writeFileSync } from 'fs'\nwriteFileSync('./bar.txt', 'es module working')\n\n// 对于第三方的 NPM 模块也可以通过 esm 加载\nimport _ from 'lodash'\n_.camelCase('ES Module')\n\n// 不支持，因为第三方模块都是导出默认成员\n// import { camelCase } from 'lodash'\n// console.log(camelCase('ES Module'))\n\n```\n\n\n\n\n\n **4.7、ES Modules 和CommonJS相互使用（在NodeJS环境中）**\n\n- ESM 中可用导入CommonJS\n- CommonJS中不能导入ESM\n- CommonJS始终只会导出一个默认成员\n- import不是解构导出对象，只能：import mod from './commonjs.js'\n\n\n\n **4.8、ES Modules 和CommonJS的差异（在NodeJS环境中）**\n```js\n// nodejs、CommonJS，文件名为：mjs\n// 加载模块函数\nconsole.log(require)\n\n// 模块对象\nconsole.log(module)\n\n// 导出对象别名\nconsole.log(exports)\n\n// 当前文件的绝对路径\nconsole.log(__filename)\n\n// 当前文件所在目录\nconsole.log(__dirname)\n\n```\n\n```js\n// nodejs、ES Modules，文件名为：mjs\n// require, module, exports 自然是通过 import 和 export 代替\n\n// __filename 和 __dirname 通过 import 对象的 meta 属性获取\n// const currentUrl = import.meta.url\n// console.log(currentUrl)\n\n// 通过 url 模块的 fileURLToPath 方法转换为路径\nimport { fileURLToPath } from 'url'\nimport { dirname } from 'path'\nconst __filename = fileURLToPath(import.meta.url)\nconst __dirname = dirname(__filename)\nconsole.log(__filename)\nconsole.log(__dirname)\n```\n\n## 5. Webpack 基于所有资源去做模块化\n完整的讲解参考后续文章：待续；\n\n5.1、支持新特性语言版本的编译\n5.2、针对javascript模块化打包\n5.3、针对所有资源，例如样式、图片、字体等进行模块化\n\n对于1、2两点，grunt、gulp等脚手架可以很好的解决，但是无法解决第3点。\n\n## 6、Rollup：专门针对ES Modules进行打包的轻量化工具 \n- webpack 大而全 => 适合做大型应用程序\n- rollup 小而美 => 适合做类库\n\n\n## 7、Parcel：零配置专用打包器，简单易用\n\n\n## 8、参考资料：\n[ES6-模块与-CommonJS-模块的差异](https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82)\n\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)","published_at":"2021-07-11T15:03:27.212Z","updated_at":"2021-07-12T07:15:26.316Z"}},"context":{}}