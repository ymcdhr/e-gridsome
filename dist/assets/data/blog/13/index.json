{"hash":"87002c5fa157b6e786d19711f6bffff4b0d9c799","data":{"data":{"id":"13","title":"前端工程化6：Webpack5配置示例，看看这些最佳实践","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"# 1. 为什么使用Webpack（应用场景）\n\n1. 支持新特性语言版本的编译\n2. 针对javascript模块化打包\n3. 针对所有资源，例如样式、图片、字体等进行模块化\n\n对于1、2两点，grunt、gulp等构建工具可以很好的解决，但是无法解决第3点。Webpack能够解决前端整体的模块化能力。\n\n# 2. 具备的能力\n\n- 模块打包器（Module bundler）—— 本身支持js模块化\n- 加载器（loader） —— 利用babel等进行语言特性编译，转换\n- 代码拆分（Code Splitting）—— 文件按需加载\n- 资源模块（Asset Module） —— 支持加载css、字体等资源\n\n\n\n# 3. 基本配置\n## 3.1 安装\n```\nnpm install webpack --save-dev\nnpm install webpack-cli --save-dev\n```\n\n\n## 3.2 入口文件：webpack.config.js\n\n#### 配置：mode\n1. production 生产模式下，Webpack 会自动优化打包结果；（例如：代码的压缩混淆等）\n2. development 开发模式下，Webpack 会自动优化打包速度，添加一些调试过程中的辅助；\n3. none 模式下，Webpack 就是运行最原始的打包，不做任何额外处理；\n\n#### 配置：entry\nentry 可以是相对路径，也可以是绝对路径\n```\n// entry 可以是多入口\nentry: {\n    index: './src/pages/index/index.js',\n    album: './src/pages/album/album.js',\n    work: './src/pages/work/work.js'\n},\n```\n#### 配置：output\noutput 必须是绝对路径\n```\nentry: {\n    index: './src/main.js'\n},\noutput: {\n    filename: '[name]-[contenthash:8].bundle.js',// contenthash:8最常用，用于避免缓存问题\n    path: path.join(__dirname, 'dist')\n},\n```\n\n#### 配置：cache\n是否打开构建缓存\n\n## 3.3 资源加载逻辑\n\n可以将js作为入口文件，在js中import css等资源\n\n- js驱动整个前端应用\n- 符合资源加载逻辑，js需要这些资源\n- 保证前端项目的开发资源不缺失\n\n![](/img/bVcS3il)\n\nwebpack兼容的几种模块化标准：ES Modules、AMD、COmmonJS\n\nwebpack加载模块的几种方式：\n\n- @import，@import(css)文件时\n- css中的background:url()函数\n- html中src属性、a标签的href（需要配置）\n\n```js\n{\n    test: /.html$/,\n    use: {\n        loader: 'html-loader',\n        options: {\n            attrs: ['img:src', 'a:href']\n        }\n    }\n}\n```\n## 3.4 loader/plugin 对比，自定义实现 loader/plugin\n- loader：用于资源加载并处理各种语言的转换/编译（例如将es6+/ts转换为js，css加载等）；\n- plugin：用于资源加载以外的其他打包/压缩/文件处理等功能；\n\n参考文章：前端工程化7\n\n## 3.5 loader加载资源文件\n#### loader：大致分为三类\n1. 编译转换\n2. 文件操作\n3. 代码检查\n\n#### loader：css样式编译（注意loader顺序，css-loader第一个执行）\n\n- 依赖：\n\n```\n> npm install css-loader --save-dev\n> npm install style/core --save-dev\n```\n- 配置：\n\n```\n  module: {\n    rules: [\n      {\n        test: /.css$/, // 匹配文件\n        use: [// use指定使用到的loader\n          'style-loader', // 将css-loader转换后的结果放到style标签里面\n          'css-loader'    // 先执行css-loader，而且是从后往前执行，所以需要放到下面 \n        ]\n      }\n    ]\n  }\n```\n\n#### loader：编译ES6+ => babel\n- 依赖：\n\n```\n> npm install babel-loader --save-dev         => babel 转换平台\n> npm install @babel/core --save-dev          => babel 核心模块\n> npm install @babel/preset-env --save-dev    => babel 转换语言包，env表示es6+全量包\n```\n- 配置：\n\n1. babel-loader：\n\n```js\n{// 转换js代码，es6+=>es5\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    use: 'babel-loader'\n},\n```\n\n2. babel.config.js（配置可以提取出来：.babelrc、.babelrc.js、babel.config.js、package.json 文件）：\n\n```js\n// .babelrc 只会影响本项目中的代码；babel.config.js 会影响整个项目中的代码，包含node_modules中的代码\n// 推荐使用：babel.config.js\nmodule.exports = {\n  presets: [\n    '@babel/preset-env'\n  ]\n}\n```\n\n3. babel 常用相关插件说明：\n\n```\n> babel-loader           => webpack中转换babel的工具，相当于一个平台不做具体的工作\n> @babel/core            => babel转换语言的核心功能，核心api等\n> @babel/preset-env      => babel转换语言的内容包，包括es6+所有特性\n\n// 以下内容待确认！\n> @babel/cli             => 使node环境支持es6语法；@babel/core也能是node环境支持es6语法；\n> @babel/polyfill        =>（一些全局方法和变量）Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。babel-polyfill相对来说比较大。\n\n> @babel/runtime  => 如果不想用babel-polyfill污染全局环境，就是用babel-runtime+babel-plugin-transform-runtime；\n> @babel/plugin-transform-runtime  => babel-plugin-transform-runtime依赖于babel-runtime\n\n> @babel/eslint-parser    => babel + eslint 的解析器（好像也没有使用？）\n\n> 插件名互换：@babel/core === 等同于 babel-core\n```\n\n#### loader：文件/图片处理\n- 依赖：\n\n```\n> npm install file-loader --save-dev\n> npm install url-loader --save-dev\n```\n- 功能：\n\n1. file-loader 普通处理\n\n```js\n{// 将图片文件复制到另一个目录\n    test: /\\.(png|svg|jpg|gif)$/,\n    loader: 'file-loader',\n    options: {\n        name: '[name]-[contenthash:8].[ext]',\n        outputPath: 'images',\n        esModule: false // 新版loader需要配置，否则会产生错误：img src=[object Module]\n    },\n},\n```\n\n2. url-loader 和 file-loader 二选一\nurl-loader 对 file-loader 有依赖，需要提前安装；\nurl-loader 将图片编码为 Base64 文件：对于小文件座大小限制进行处理，减少请求次数。\n\n```js\n{// 将小于10kb的图片编码成base64\n    test: /\\.(png|svg|jpg|gif)$/,\n    use: {\n        loader: 'url-loader',  // url-loader对file-loader有依赖，需要提前安装\n        options: {\n            name: '[name]-[contenthash:8].[ext]',\n            outputPath: 'images',\n            limit: 10 * 1024,  // 10 KB 对文件大小进行限制，超过就不转换\n            esModule: false    // 新版loader需要配置，否则会产生错误：img src=[object Module]\n        },\n    }\n}\n```\n#### loader：html处理（用得少，使用其他插件替代）\n\n依赖：\n```\n> npm install html-loader --save-dev\n```\n\n## 3.6 plugins插件处理其他任务\n\n#### plugin：自动生成html文件插件\n- 依赖：html-webpack-plugin\n- 功能：\n\n1. 基础配置\n\n```\n// 用于生成 index.html\nnew HtmlWebpackPlugin({\n    title: 'index首页',\n    meta: {\n        viewport: 'width=device-width'\n    },\n    minify: {\n        removeAttributeQuotes: true     // 移除属性的引号\n    },\n    inject: true,                       // script是否至于body底部\n    template: './src/templates/index.html',\n    filename: 'index.html',\n    // cache: false,\n    chunks: ['index'],                  // 指定加载js文件，默认全部加载\n    // showErrors: true,                // 如果 webpack 编译出现错误，webpack会将错误信息包裹在一个 pre 标签内，属性的默认值为 true ，也就是显示错误信息。\n}),\n```\n\n2. 在html模板中使用变量：\n\n```html\n  <title>Home - <%= htmlWebpackPlugin.options.title %></title>\n```\n\n#### plugin：根据目录自动生成html文件\n- 依赖：auto-web-plugin\n\n#### plugin：自动清除输出目录插件\n- 依赖：clean-webpack-plugin\n\n#### plugin：拷贝文件的插件\n- 依赖：copy-webpack-plugin\n\n```\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\n\nmodule.exports = merge(common, {\n    mode: 'production',\n    plugins: [\n      new CleanWebpackPlugin(),\n      new CopyWebpackPlugin({\n        patterns: [\n            { from: \"./public/*.ico\", to: \"./\"},\n        ],\n      })\n    ]\n})\n```\n\n\n\n# 4. 增强体验\n## 4.1、热更新\n#### 方案1：webpack + browser-sync（本地磁盘可见文件）\n- 依赖：\n\n```\n> npm install browser-sync --save-dev\n```\n- 功能：\n\n1. 自动编译，监控源文件；使用webpack自带配置\n\n```\n// 1、npm scripts中 => webpack携带命令行参数或者添加配置项\n> webpack --watch\n\n// 2、webpack.config.js => webpack配置项\nwatch: true, // 监听所有文件的更改，自动构建自动刷新浏览器\n```\n\n2. 自动刷新浏览器，监控打包文件；使用工具browser-sync\n\n```\n> npm install browser-sync --save-dev\n```\n\n```\n  \"scripts\": {\n    \"dev\": \"webpack --config webpack.dev.js\",   // 配置项配了watch就可以不带参数--wacth\n    \"sync\": \"browser-sync dist --files '**/*'\", // 带参数--files\n  }\n```\n\n3. 需要同时启用两个命令行：\n\n```\nwebpack-sample> npm run dev\nwebpack-sample> npm run sync\n```\n\n#### 方案2：webapck-dev-server工具（内存中看不到文件）\n- 依赖：\n\n```\n> npm install webapck-dev-server --save-dev\n```\n- 功能：集成了自动编译和自动刷新浏览器，注意watch和target的配置\n\n- 基本配置 :\n\n```\n1. contentBase  => 基本路径 \n2. open         => 自动打开浏览器\n3. host         => 虚拟主机地址\n4. port         => 端口号\n5. proxy（代理） => 代理配置\n```\n- 完整示例：\n\n```js\n    // watch: true,             // 热更新方案1：监听源码文件更改自动构建，监听磁盘文件自动刷新浏览器（配合browser-sync刷新浏览器）\n    target: \"web\",              // webpack5的一个bug，需要打开才能自动刷新浏览器，参考：https://blog.csdn.net/xiaolongbaobushibao/article/details/116664883\n                                // 使用devServer是不用打开watch\n                                // 使用devServer常见不刷新浏览器情况：\n    devServer: {                // 热更新方案2：本地开发服务器，监听源码文件自动构建和刷新浏览器，打包结果存在内存而不是磁盘中\n        host: '127.0.0.1',  \n        port: '8080',\n        // hot: true,           // 模块热替换，如果热替换失败就自动回到页面自动刷新\n        // hotOnly: true,       // 模块热替换，如果热替换失败不会自动刷新页面\n        contentBase: path.resolve(__dirname,'dist'),// 指定静态资源路径的根目录，需要对应output:path为dist，\n        open: true,             // 自动打开浏览器\n        // watchContentBase: true,\n        inline: true\n        // proxy: {             // 配置代理，防止跨域问题\n        //     '/api': {\n        //         target: 'https://api.github.com', // http://localhost:8080/api/users -> https://api.github.com/api/users\n        //         pathRewrite: {                    // http://localhost:8080/api/users -> https://api.github.com/users\n        //             '^/api': ''\n        //         },\n        //         // 不能使用 localhost:8080 作为请求 GitHub 的主机名\n        //         changeOrigin: true\n        //     }\n        // }\n    },\n```\n\n- **webpack dev server不能只能刷新浏览器的问题** \n\n1. webpack5的一个bug，参考：https://blog.csdn.net/xiaolongbaobushibao/article/details/116664883\n\n```\n// webpack.config.js中添加配置项\ntarget: \"web\",\n```\n2. 提取了公用代码，一些配置路径错误等问题；例如：检查optimization、path、publicPath、contentBase等配置项\n\n#### 热更新最佳实践（个人认为）：\n\n-  **本地开发最初调试阶段** （dev）=> 使用 webpack-dev-server，只有浏览器内存能看到代码\n-  **本地测试或者联调阶段** （dev/pre）=> 使用 webpack + browser-sync，能看到本地代码\n> 因为开发阶段很多文件没有合并压缩，跟生产环境差异太大。用webpack-dev-server有些东西测不出来。\n-  **预上线、生产上线阶段** （sit、prd） => 使用文件合并、压缩过后的完整代码\n\n\n\n\n\n\n\n## 4.2、模块热加载\n#### webapck-dev-server中 HMR 模块的热更新：\n\n **注意事项：** \n1. HMR需要新增一些代码，用来手动处理JS模块的热替换、图片模块热替换等（因为不同的业务场景需要处理的数据不同）。\n2. HMR新增代码与业务无关，所以会增加一定工作量；而且写起来比较麻烦，建议结合框架使用完善的HMR方案。\n3. HMR新增代码与业务无关，但是在webpack打包过后其实是删除了的，对生产环境没有影响。\n\n\n **使用场景：** \n\n1. 在页面中有一个编辑器，在编辑器中输入内容然后再修改样式。webapck-dev-server负责刷新整体页面，如果每次修改了样式后页面刷新，编辑器中的内容就会丢失。HMR插件能实现在页面不刷新的情况下，局部模块的更新。<br>\n2. 在开发过程中频繁修改页面某个模块的样式，例如：背景图片。\n\n\n **如何使用：** \n1. 命令行参数： webpack-dev-server --hot\n2. 配置文件：\n\n```js\n// 1、引入webpack\nconst webpack = require('webpack')\n\n\n// 2、plugins里面添加内置插件：\nplugins: [\n    new webpack.HotModuleReplacementPlugin()\n    ...\n],\n\n// 3、devServer中添加配置项：\n// 注意：在热替换手动处理js热替换，如果报错热替换会启动失败；\n// 注意：使用hotOly，热替换失败也不会自动刷新页面。\ndevServer: {\n    // 可能出现的错误1：处理的热替换模块有错误，使用hotOnly配置\n    // hot: true,  // 模块热替换，如果热替换失败就自动回到页面自动刷新\n    hotOnly: true, // 模块热替换，如果热替换失败不会自动刷新页面便于定位问题\n    ...\n}\n\n```\n\n **处理JS模块的热替换** \n\n1. webpack中的热替换api：module.hot.accept 用于注册模块处理函数\n\n\n2. 示例场景：修改编辑器模块代码后，热更新编辑器模块\n\n```js\n// 可能出现的错误2：plugins没有开启配置会报错，需要在热替换代码中对module.hot进行判断\nif (module.hot) {\n  let lastEditor = editor\n\n  // 1、编辑器的热替换\n  // 参数1：模块\n  // 参数2：处理函数 => 实现的功能：简单来说就是用js代码更新一下模块内需要更新的内容（重要），例如下面更新了编辑器。\n  module.hot.accept('./editor', () => {\n\n    //移除原来编辑器，记录数据\n    const value = lastEditor.innerHTML\n    document.body.removeChild(lastEditor) \n\n    //更新原来的数据到新的编辑器\n    const newEditor = createEditor()\n    newEditor.innerHTML = value\n    document.body.appendChild(newEditor)\n    lastEditor = newEditor\n  })\n\n  // 2、图片的热替换\n  module.hot.accept('./better.png', () => {\n    img.src = background\n    console.log(background)\n  })\n}\n```\n\n3. 可能出现的错误：\n- 可能出现的错误1：处理的热替换模块有错误，使用hotOnly配置\n- 可能出现的错误2：plugins没有开启配置会报错，需要在热替换代码中对module.hot进行判断\n\n\n  **处理图片模块的热替换** \n```js\n  // 2、图片的热替换\n  module.hot.accept('./better.png', () => {\n    img.src = background\n    console.log(background)\n  })\n```\n\n **VUE + HMR 方案** \n\n参考：[自己网上找]()\n\n **REACT + HMR 方案** \n\n参考：[自己网上找]()\n\n\n\n\n\n\n## 4.3、配置Source Map （便于查看调试代码）\n记录代码转换前后的映射关系\n\n#### Source Map配置方案\n **webpack中的devTool，按照以下3中规则配置：** \n1. eval                  => 使用eval执行模块代码，没有生成对应的.map文件；只能看到错误对应的文件名称；\n2. source-map            => 包含错误的行列信息\n3. cheap                 => 不包含错误的列信息\n4. module                => 不要loader处理源码\n5. inline                => 将.map文件以data-url的形式生成放到url中，很占体积\n\n\n **带eval不生成.map文件：** \n- eval：构建速度最快，只能定位错误文件是哪个；\n- eval-source-map：错误文件名称 + 错误的行列；\n- cheap-eval-source-map：错误文件名称 + 错误的行；\n- cheap-module-eval-source-map：错误文件名称 + 错误的行 + 代码未被loader处理；\n\n\n **不带eval都生成了.map文件：** \n- source-map：错误文件名称 + 错误的行列；\n- cheap-source-map：错误文件名称 + 错误的行 + 代码未被loader处理；\n- hidden-source-map：代码中看不见source-map源码（适合开发第三方工具，需要的时候再使用）；\n- nosources-source-map：看不到源码，只能看到错误行列号（生产环境可以保护源码）；\n\n\n **带inline不生成.map文件，将其放到url中（不推荐使用inline）：** \n- inline-source-map：将source-map以data-url方式嵌入到url中，导致代码体积变大；\n\n\n **最佳实践：**\n \n- 开发模式：eval-cheap-module-source-map//webpack5中这几个单词顺序不能变，前提是：\n> 1、代码每行不超过80字符\n> 2、Loader转换过后代码差异大，所以需要看源码\n> 3、这种模式启动慢，但是重新打包速度快\n> **4、注意：webpack5中对这几个单词顺序有要求，必须是：** \n> - ^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$\n> - eval-cheap-module-source-map => ok\n> - cheap-module-eval-source-map => old这种就会报错\n\n- 生产模式：none、nosources-source-map\n> 1、这样可以避免暴露源码\n\n\n## 4.4、配置路径别名\n```js\nalias: {\n    '@': resolve('src'),\n    '@config': resolve('config')\n}\n```\n\n\n## 4.5、配置涉及到的路径：publicPath （未完待续，待整理）\n- __dirname\n- process.cwd()\n- path.join(__dirname, 'dist')\n- path.resolve(__dirname, 'dist')\n- './dist'\n- '/dist/'\n\n```js\n// ...\n```\n\n\n\n# 5. 生产环境配置\n## 5.1 根据环境添加不同的配置\n\n#### 方案1：根据命令行参数判断\n **如何判断环境：** 命令行--env production参数会传递给env；\n```\n> webpack --env production\n```\n\n **接收参数：** \n\nwebpack 除了可以直接导出配置；还可以导出一个function，返回配置：\n```js\nmodule.exports = config\nmodule.exports = (env, args)=> config\n```\n\n1. 命令行webpack --env production参数会传递给function的参数env；\n2. 可以在function中对env环境进行判断：\n\n```js\n// webpack提供了一个函数\n// 参数1：env\n// 参数2：args\n// 返回值：配置项\nmodule.exports = (env, args) => {\n    const config = {\n        //...\n    }\n\n    // env 接受参数：webpack --env production\n    if (env === 'production') {\n        config.mode = 'production'\n        config.devtool = false\n        config.plugins = [\n          ...config.plugins,\n          new CleanWebpackPlugin(),\n          new CopyWebpackPlugin(['public'])\n        ]\n    }\n    \n    return config\n}\n```\n\n#### 方案2：提取公用配置到文件，将配置独立到三个文件：=> 最好用\n\n- 依赖：webpack-merge插件\n\n```\n> npm install webpack-merge --save-dev  => 专业用于合并webpack配置项对象的插件\n```\n\n- 功能：将配置独立到三个文件，prod、dev合并公用配置\n\n```\n> webpack.common.js // 公用配置 \n> webpack.prod.js   // 生产环境\n> webpack.dev.js    // 开发环境\n```\n- 例如单独配置prd环境的js，合并webpack.common.js中的配置\n\n```js\n// 合并配置，比较专业的模块：webpack-merge\n// 合并配置，最好不要用Object.assign，它在复制对象时后面的配置会完全覆盖掉前面的配置\nconst { merge } = require('webpack-merge')\n\nconst common = require('./webpack.common.js')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\n\nmodule.exports = merge(common, {\n    mode: 'production',\n    plugins: [\n      new CleanWebpackPlugin(),\n      new CopyWebpackPlugin(['public'])\n    ]\n})\n```\n\n\n#### 方案3：plugin：DefinePlugin，向打包文件中注入环境变量在webpack打包时判断\n\n- 依赖：无，webpack内置插件：webpack.DefinePlugin\n- 功能：DefinePlugin插件可以向webpack打包文件中注入js代码直接使用，例如：\n\n```js\nplugins: [\n    new webpack.DefinePlugin({\n      // 值要求的是一个代码片段\n      TEST_URL: 'https://api.example.com'，\n      API_BASE_URL: JSON.stringify('https://api.example.com')\n    })\n  ]\n```\n在源码中使用变量，打包到 bundle.js ==> \n```js\n// console.log(TEST_URL)，注意没有引号，不是字符串\nconsole.log(https://api.example.com)\n\n// console.log(API_BASE_URL)，所以需要JSON.stringify()\nconsole.log('https://api.example.com')\n```\n\n- **DefinePlugin 配合 process.end.NODE_ENV 使用**\n\n1. process.end.NODE_ENV 获取执行环境\n2. process是在nodejs环境中的全局变量，只能在webpack.config.js中使用；\n3. 想要在源码中使用process判断环境，需要使用插件：DefinePlugin将process变量注入到打包文件。\n4. 以下示例，将环境变量注入到源码boudle.js：process.env.NODE_ENV\n\n```js\nnew webpack.DefinePlugin({\n    PRODUCTION: JSON.stringify(true),\n    VERSION: JSON.stringify('0.0.1'),\n    API_BASE_URL: JSON.stringify('https://api.example.com')\n    'process.env': {\n         NODE_ENV: JSON.stringify(process.env.NODE_ENV)\n     }\n});\n```\n\n- **process.end.NODE_ENV使用时的兼容性问题** ，在npm scripts中添加：\n\nwindows/linux兼容：\n```\ncross-env NODE_ENV=development\n```\nwindows：\n```\nSET NODE_ENV=development\n```\nos x/linux：\n```\nexport NODE_ENV=development\n```\n\n\n\n\n# 6. 优化打包性能\n\n## 6.1 Tree Shaking 功能\n#### 基本使用\n将未使用的代码处理掉，合并模块等功能；没有依赖项。\n\n- 生产环境下自动启用\n- 其他环境下开启配置\n\n```\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  optimization: {\n    // 模块只导出被使用的成员\n    usedExports: true,\n    \n    // 压缩输出结果，usedExports开启后会移除未被使用的成员\n    // minimize: true,\n\n    // 尽可能合并每一个模块到一个函数中（Scop Hosting）\n    concatenateModules: true,\n  }\n}\n```\n\n\n#### Tree Shaking和Babel（未完待续）\n据说是用babel时，tree shaking会失效？\n- tree shaking前提是 ESM Modules，由webpack打包的代码必须是用EMS\n- babel preset-env这个插件就是将es6+转换为es5，而且它是将ESM => 转换为CommonJS的方式，导致tree shaking失效（Babel到底是将什么ESM转换为CommonJS，待梳理~~~~~~~~~~~）\n- 最新版本的Babel自动关闭了 ESM 转换插件，ESM并没有转换；所以tree shaking可以正常工作。\n\n```js\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              // 如果 Babel 加载模块时已经转换了 ESM，则会导致 Tree Shaking 失效；最新版本的Babel自动关闭了 ESM 转换插件\n              // ['@babel/preset-env', { modules: 'commonjs' }] // 强制将ESM转换为CommonJS，tree shaking失效\n              // ['@babel/preset-env', { modules: false }] // 强制关闭转换插件\n              // 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 ESM 转换\n              ['@babel/preset-env', { modules: 'auto' }]\n            ]\n          }\n        }\n      }\n    ]\n```\n\n#### Tree Shaking与sideEffects（未完待续，使用场景待研究）\n **sideEffects使用场景：** \n\n如果有定义了很多模块（例如多个组件），但实际上只使用了一个；打包的时候需要删除多余的代码，可以用sideEffects配置。\n\n- 生产环境下自动启用\n- 开发环境下如下配置\n\n\n **sideEffects配置**\n \nwebpack.config.js 下的配置\n```js\n  // webpack.config.js 下的配置\n  optimization: {\n    sideEffects: true,//打开移除未使用的模块\n  }\n```\n\npackage.json下的配置：\n```js\n// package.json的配置和webpack下的配置意义不同，此处只是标识代码没有副作用\n\"sideEffects\": false // 标识代码没有副作用，webpack在打包时会删掉有副作用的代码\n```\n\n## 6.2 多入口打包 => 解决文件过大的问题\n#### 方案1：多个html-webpack-plugin\n- 依赖：\n\n```\n> npm install html-webpack-plugin --save-dev\n```\n- 功能：\nentry 定义多个入口并使用多个 HtmlWebpackPlugin() 插件；具体参考示例源码；\n\n\n#### 方案2：使用auto-web-plugin插件按照目录生成html\n- 依赖：\n\n```\n> npm install auto-web-plugin --save-dev\n```\n- 功能：（未完待续）\n\n```js\n// ...\n```\n\n## 6.3 CodeSplit代码分片，按需加载 => 解决文件过大的问题\n- 依赖：无\n- 功能：使用动态加载语句：import('./components/banner.js').then(banner => {})\n- 实践：通常和路由相结合，不需要其他配置\n\n```js\n\nconst render = () => {\n  const hash = window.location.hash || '#posts'\n  const mainElement = document.querySelector('.main')\n  mainElement.innerHTML = ''\n\n  if (hash === '#posts') {\n    // mainElement.appendChild(posts())\n    // /* webpackChunkName: 'components' */为魔法注释，可用将两个模块合并到同一个文件名中\n    import(/* webpackChunkName: 'components' */'./posts/posts').then(({ default: posts }) => {\n      mainElement.appendChild(posts())\n    })\n  } else if (hash === '#album') {\n    // mainElement.appendChild(album())\n    import(/* webpackChunkName: 'components' */''./album/album').then(({ default: album }) => {\n      mainElement.appendChild(album())\n    })\n  }\n}\n\nrender()\n\nwindow.addEventListener('hashchange', render)\n```\n\n- 配合VUE-ROUTER示例：（未完待续）\n\n```js\nconst routes = [\n  {\n    path: '/',\n    name: 'Index',\n    component: Index\n  },\n  {\n    path: '/detail/:id',\n    name: 'Detail',\n    props: true,\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackChunkName: \"detail\" */ '../views/Detail.vue')\n  }\n]\n```\n\n## 6.4 splitChunks，提取js公共代码\n- 依赖：无，直接在optimization中配置\n- 功能：取代了webpack4中的CommonsChunkPlugin，默认值是按需加载的 chunks；参考：https://webpack.docschina.org/plugins/split-chunks-plugin/\n\n```js\noptimization: {\n    splitChunks: {\n        // 自动提取所有公共模块到单独 bundle；可选配置有：all，async 和 initial。\n        // 设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享\n        chunks: 'all'\n    }\n},\n```\n\n## 6.5 MiniCssExtractPlugin，提取CSS到单个文件\n- 依赖：\n\n```\n> npm install mini-css-extract-plugin --save-dev             => 将样式存放到单独的css文件中，取代style-loader\n> npm install optimize-css-assets-webpack-plugin --save-dev  => 手动打开css压缩代码\n> npm install terser-webpack-plugin --save-dev               => 手动打开js压缩代码\n```\n- 功能：\n\n1. 将css代码存放到单独的css文件中，是否也可以合并css文件？（待研究：https://webpack.docschina.org/plugins/mini-css-extract-plugin/）\n2. 配合css-loader，不再需要style-loader；\n\n```js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n// ...\n\n  optimization: {\n    minimizer: [// 使用了minimizer，webpack认为不再启动自动压缩js代码\n      new TerserWebpackPlugin(),            //手动打开js压缩代码\n      new OptimizeCssAssetsWebpackPlugin()  //手动打开css压缩代码\n    ]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 'style-loader', // 将样式通过 style 标签注入\n          MiniCssExtractPlugin.loader, // 将样式存放到单独的css文件中\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    ...，\n    new MiniCssExtractPlugin()\n  ]\n```\n\n## 6.6 ExtractTextPlugin、MiniCssExtractPlugin哪个更好用？\n\n1. MiniCssExtractPlugin基于 webpack v4 的新特性（模块类型）构建，并且需要 webpack 4 才能正常工作。\n2. 与 extract-text-webpack-plugin 相比，MiniCssExtractPlugin：\n> https://webpack.docschina.org/plugins/mini-css-extract-plugin/\n- 异步加载\n- 没有重复的编译（性能）\n- 更容易使用\n- 特别针对 CSS 开发\n\n## 6.7 文件名hash，解决缓存带来的问题\n **webpack中有三种hash：** \n1. 项目级别：filename: '[name]-[hash].bundle.js' —— 项目中任何改动都会修改hash\n2. Chunk级别：filename: '[name]-[chunkhash].bundle.js' —— 同一路chunk改动会修改hash\n3. 内容级别：filename: '[name]-[contenthash].bundle.js' —— 文件发生变化时才会改变hash\n\n\n **最佳方案：** 使用contenthash:8，并且后面可以指定位数：8位。\n\n```js\n  output: {\n    filename: '[name]-[contenthash:8].bundle.js'\n  },\n  ...\n  plugins: [\n    ...,\n    new MiniCssExtractPlugin({\n      filename: '[name]-[contenthash:8].bundle.css'\n    })\n  ]\n\n```\n\n\n## 6.8 Happypack：多线程并行打包\nwebpack4 之后推荐使用 thread-loader；而且 happypack 已经没怎么维护了，和 vue-loader 配合也会有一些配置问题；\n\n\n## 6.9 其它提高构建性能的方案\n官方建议：https://webpack.docschina.org/guides/build-performance/\n\n **如何对webpack构建性能进行分析：** \n\n参考文档：https://juejin.cn/post/6911519627772329991\n\n```\n> npm install --save-dev speed-measure-webpack-plugin  => 分析 webpack 打包速度\n> npm install --save-dev webpack-bundle-analyzer       => 分析 webpack 打包模块大小\n```\n **提升构建速度方案（主要的几个）：** \n\n1. 通过使用 include 字段减小打包范围\n2. 使用 DllPlugin 为更改不频繁的代码生成单独的打包文件；配置参考：https://webpack.docschina.org/plugins/dll-plugin/\n3. 多使用分片按需加载功能，SplitChunksPlugin 配置；\n4. 使用 thread-loader，功能类似于happypack；创建多线程打包，配置参考：https://webpack.docschina.org/loaders/thread-loader/#root\n\n```\n1. 请仅在耗时的操作中使用 thread-loader，因为：在 worker 池中运行的 loader 是受到限制的；具体参考文档。\n2. 不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 main process(主进程) 之间的模块传输。进程间通讯(IPC, inter process communication)是非常消耗资源的。\n```\n\n5. 使用配置项：cache，缓存生成的 webpack 模块和 chunk，来改善构建速度。cache 会在开发 模式被设置成 type: 'memory' 而且在 生产 模式 中被禁用。 参考：https://webpack.docschina.org/configuration/other-options/#cache\n6. 开发阶段尽量使用 webpack-dev-server 在内存中构建\n7. 配置 devTool 生成映射文件时选择合适的选项\n8. // ...\n\n# 7. 示例代码\nhttps://gitee.com/ymcdhr/e-demo/tree/master/webpack-sample\n\n# 8. 参考资料：\nhttps://webpack.docschina.org/guides/\nhttps://webpack.docschina.org/guides/build-performance/\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)","published_at":"2021-07-11T18:21:57.780Z","updated_at":"2021-07-12T07:15:26.316Z"}},"context":{}}