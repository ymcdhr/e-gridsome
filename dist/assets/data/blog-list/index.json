{"hash":"87002c5fa157b6e786d19711f6bffff4b0d9c799","data":{"data":{"pageInfo":{"totalPages":2,"currentPage":1},"edges":[{"node":{"id":"13","title":"前端工程化6：Webpack5配置示例，看看这些最佳实践","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"# 1. 为什么使用Webpack（应用场景）\n\n1. 支持新特性语言版本的编译\n2. 针对javascript模块化打包\n3. 针对所有资源，例如样式、图片、字体等进行模块化\n\n对于1、2两点，grunt、gulp等构建工具可以很好的解决，但是无法解决第3点。Webpack能够解决前端整体的模块化能力。\n\n# 2. 具备的能力\n\n- 模块打包器（Module bundler）—— 本身支持js模块化\n- 加载器（loader） —— 利用babel等进行语言特性编译，转换\n- 代码拆分（Code Splitting）—— 文件按需加载\n- 资源模块（Asset Module） —— 支持加载css、字体等资源\n\n\n\n# 3. 基本配置\n## 3.1 安装\n```\nnpm install webpack --save-dev\nnpm install webpack-cli --save-dev\n```\n\n\n## 3.2 入口文件：webpack.config.js\n\n#### 配置：mode\n1. production 生产模式下，Webpack 会自动优化打包结果；（例如：代码的压缩混淆等）\n2. development 开发模式下，Webpack 会自动优化打包速度，添加一些调试过程中的辅助；\n3. none 模式下，Webpack 就是运行最原始的打包，不做任何额外处理；\n\n#### 配置：entry\nentry 可以是相对路径，也可以是绝对路径\n```\n// entry 可以是多入口\nentry: {\n    index: './src/pages/index/index.js',\n    album: './src/pages/album/album.js',\n    work: './src/pages/work/work.js'\n},\n```\n#### 配置：output\noutput 必须是绝对路径\n```\nentry: {\n    index: './src/main.js'\n},\noutput: {\n    filename: '[name]-[contenthash:8].bundle.js',// contenthash:8最常用，用于避免缓存问题\n    path: path.join(__dirname, 'dist')\n},\n```\n\n#### 配置：cache\n是否打开构建缓存\n\n## 3.3 资源加载逻辑\n\n可以将js作为入口文件，在js中import css等资源\n\n- js驱动整个前端应用\n- 符合资源加载逻辑，js需要这些资源\n- 保证前端项目的开发资源不缺失\n\n![](/img/bVcS3il)\n\nwebpack兼容的几种模块化标准：ES Modules、AMD、COmmonJS\n\nwebpack加载模块的几种方式：\n\n- @import，@import(css)文件时\n- css中的background:url()函数\n- html中src属性、a标签的href（需要配置）\n\n```js\n{\n    test: /.html$/,\n    use: {\n        loader: 'html-loader',\n        options: {\n            attrs: ['img:src', 'a:href']\n        }\n    }\n}\n```\n## 3.4 loader/plugin 对比，自定义实现 loader/plugin\n- loader：用于资源加载并处理各种语言的转换/编译（例如将es6+/ts转换为js，css加载等）；\n- plugin：用于资源加载以外的其他打包/压缩/文件处理等功能；\n\n参考文章：前端工程化7\n\n## 3.5 loader加载资源文件\n#### loader：大致分为三类\n1. 编译转换\n2. 文件操作\n3. 代码检查\n\n#### loader：css样式编译（注意loader顺序，css-loader第一个执行）\n\n- 依赖：\n\n```\n> npm install css-loader --save-dev\n> npm install style/core --save-dev\n```\n- 配置：\n\n```\n  module: {\n    rules: [\n      {\n        test: /.css$/, // 匹配文件\n        use: [// use指定使用到的loader\n          'style-loader', // 将css-loader转换后的结果放到style标签里面\n          'css-loader'    // 先执行css-loader，而且是从后往前执行，所以需要放到下面 \n        ]\n      }\n    ]\n  }\n```\n\n#### loader：编译ES6+ => babel\n- 依赖：\n\n```\n> npm install babel-loader --save-dev         => babel 转换平台\n> npm install @babel/core --save-dev          => babel 核心模块\n> npm install @babel/preset-env --save-dev    => babel 转换语言包，env表示es6+全量包\n```\n- 配置：\n\n1. babel-loader：\n\n```js\n{// 转换js代码，es6+=>es5\n    test: /\\.js$/,\n    exclude: /node_modules/,\n    use: 'babel-loader'\n},\n```\n\n2. babel.config.js（配置可以提取出来：.babelrc、.babelrc.js、babel.config.js、package.json 文件）：\n\n```js\n// .babelrc 只会影响本项目中的代码；babel.config.js 会影响整个项目中的代码，包含node_modules中的代码\n// 推荐使用：babel.config.js\nmodule.exports = {\n  presets: [\n    '@babel/preset-env'\n  ]\n}\n```\n\n3. babel 常用相关插件说明：\n\n```\n> babel-loader           => webpack中转换babel的工具，相当于一个平台不做具体的工作\n> @babel/core            => babel转换语言的核心功能，核心api等\n> @babel/preset-env      => babel转换语言的内容包，包括es6+所有特性\n\n// 以下内容待确认！\n> @babel/cli             => 使node环境支持es6语法；@babel/core也能是node环境支持es6语法；\n> @babel/polyfill        =>（一些全局方法和变量）Babel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。babel-polyfill相对来说比较大。\n\n> @babel/runtime  => 如果不想用babel-polyfill污染全局环境，就是用babel-runtime+babel-plugin-transform-runtime；\n> @babel/plugin-transform-runtime  => babel-plugin-transform-runtime依赖于babel-runtime\n\n> @babel/eslint-parser    => babel + eslint 的解析器（好像也没有使用？）\n\n> 插件名互换：@babel/core === 等同于 babel-core\n```\n\n#### loader：文件/图片处理\n- 依赖：\n\n```\n> npm install file-loader --save-dev\n> npm install url-loader --save-dev\n```\n- 功能：\n\n1. file-loader 普通处理\n\n```js\n{// 将图片文件复制到另一个目录\n    test: /\\.(png|svg|jpg|gif)$/,\n    loader: 'file-loader',\n    options: {\n        name: '[name]-[contenthash:8].[ext]',\n        outputPath: 'images',\n        esModule: false // 新版loader需要配置，否则会产生错误：img src=[object Module]\n    },\n},\n```\n\n2. url-loader 和 file-loader 二选一\nurl-loader 对 file-loader 有依赖，需要提前安装；\nurl-loader 将图片编码为 Base64 文件：对于小文件座大小限制进行处理，减少请求次数。\n\n```js\n{// 将小于10kb的图片编码成base64\n    test: /\\.(png|svg|jpg|gif)$/,\n    use: {\n        loader: 'url-loader',  // url-loader对file-loader有依赖，需要提前安装\n        options: {\n            name: '[name]-[contenthash:8].[ext]',\n            outputPath: 'images',\n            limit: 10 * 1024,  // 10 KB 对文件大小进行限制，超过就不转换\n            esModule: false    // 新版loader需要配置，否则会产生错误：img src=[object Module]\n        },\n    }\n}\n```\n#### loader：html处理（用得少，使用其他插件替代）\n\n依赖：\n```\n> npm install html-loader --save-dev\n```\n\n## 3.6 plugins插件处理其他任务\n\n#### plugin：自动生成html文件插件\n- 依赖：html-webpack-plugin\n- 功能：\n\n1. 基础配置\n\n```\n// 用于生成 index.html\nnew HtmlWebpackPlugin({\n    title: 'index首页',\n    meta: {\n        viewport: 'width=device-width'\n    },\n    minify: {\n        removeAttributeQuotes: true     // 移除属性的引号\n    },\n    inject: true,                       // script是否至于body底部\n    template: './src/templates/index.html',\n    filename: 'index.html',\n    // cache: false,\n    chunks: ['index'],                  // 指定加载js文件，默认全部加载\n    // showErrors: true,                // 如果 webpack 编译出现错误，webpack会将错误信息包裹在一个 pre 标签内，属性的默认值为 true ，也就是显示错误信息。\n}),\n```\n\n2. 在html模板中使用变量：\n\n```html\n  <title>Home - <%= htmlWebpackPlugin.options.title %></title>\n```\n\n#### plugin：根据目录自动生成html文件\n- 依赖：auto-web-plugin\n\n#### plugin：自动清除输出目录插件\n- 依赖：clean-webpack-plugin\n\n#### plugin：拷贝文件的插件\n- 依赖：copy-webpack-plugin\n\n```\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\n\nmodule.exports = merge(common, {\n    mode: 'production',\n    plugins: [\n      new CleanWebpackPlugin(),\n      new CopyWebpackPlugin({\n        patterns: [\n            { from: \"./public/*.ico\", to: \"./\"},\n        ],\n      })\n    ]\n})\n```\n\n\n\n# 4. 增强体验\n## 4.1、热更新\n#### 方案1：webpack + browser-sync（本地磁盘可见文件）\n- 依赖：\n\n```\n> npm install browser-sync --save-dev\n```\n- 功能：\n\n1. 自动编译，监控源文件；使用webpack自带配置\n\n```\n// 1、npm scripts中 => webpack携带命令行参数或者添加配置项\n> webpack --watch\n\n// 2、webpack.config.js => webpack配置项\nwatch: true, // 监听所有文件的更改，自动构建自动刷新浏览器\n```\n\n2. 自动刷新浏览器，监控打包文件；使用工具browser-sync\n\n```\n> npm install browser-sync --save-dev\n```\n\n```\n  \"scripts\": {\n    \"dev\": \"webpack --config webpack.dev.js\",   // 配置项配了watch就可以不带参数--wacth\n    \"sync\": \"browser-sync dist --files '**/*'\", // 带参数--files\n  }\n```\n\n3. 需要同时启用两个命令行：\n\n```\nwebpack-sample> npm run dev\nwebpack-sample> npm run sync\n```\n\n#### 方案2：webapck-dev-server工具（内存中看不到文件）\n- 依赖：\n\n```\n> npm install webapck-dev-server --save-dev\n```\n- 功能：集成了自动编译和自动刷新浏览器，注意watch和target的配置\n\n- 基本配置 :\n\n```\n1. contentBase  => 基本路径 \n2. open         => 自动打开浏览器\n3. host         => 虚拟主机地址\n4. port         => 端口号\n5. proxy（代理） => 代理配置\n```\n- 完整示例：\n\n```js\n    // watch: true,             // 热更新方案1：监听源码文件更改自动构建，监听磁盘文件自动刷新浏览器（配合browser-sync刷新浏览器）\n    target: \"web\",              // webpack5的一个bug，需要打开才能自动刷新浏览器，参考：https://blog.csdn.net/xiaolongbaobushibao/article/details/116664883\n                                // 使用devServer是不用打开watch\n                                // 使用devServer常见不刷新浏览器情况：\n    devServer: {                // 热更新方案2：本地开发服务器，监听源码文件自动构建和刷新浏览器，打包结果存在内存而不是磁盘中\n        host: '127.0.0.1',  \n        port: '8080',\n        // hot: true,           // 模块热替换，如果热替换失败就自动回到页面自动刷新\n        // hotOnly: true,       // 模块热替换，如果热替换失败不会自动刷新页面\n        contentBase: path.resolve(__dirname,'dist'),// 指定静态资源路径的根目录，需要对应output:path为dist，\n        open: true,             // 自动打开浏览器\n        // watchContentBase: true,\n        inline: true\n        // proxy: {             // 配置代理，防止跨域问题\n        //     '/api': {\n        //         target: 'https://api.github.com', // http://localhost:8080/api/users -> https://api.github.com/api/users\n        //         pathRewrite: {                    // http://localhost:8080/api/users -> https://api.github.com/users\n        //             '^/api': ''\n        //         },\n        //         // 不能使用 localhost:8080 作为请求 GitHub 的主机名\n        //         changeOrigin: true\n        //     }\n        // }\n    },\n```\n\n- **webpack dev server不能只能刷新浏览器的问题** \n\n1. webpack5的一个bug，参考：https://blog.csdn.net/xiaolongbaobushibao/article/details/116664883\n\n```\n// webpack.config.js中添加配置项\ntarget: \"web\",\n```\n2. 提取了公用代码，一些配置路径错误等问题；例如：检查optimization、path、publicPath、contentBase等配置项\n\n#### 热更新最佳实践（个人认为）：\n\n-  **本地开发最初调试阶段** （dev）=> 使用 webpack-dev-server，只有浏览器内存能看到代码\n-  **本地测试或者联调阶段** （dev/pre）=> 使用 webpack + browser-sync，能看到本地代码\n> 因为开发阶段很多文件没有合并压缩，跟生产环境差异太大。用webpack-dev-server有些东西测不出来。\n-  **预上线、生产上线阶段** （sit、prd） => 使用文件合并、压缩过后的完整代码\n\n\n\n\n\n\n\n## 4.2、模块热加载\n#### webapck-dev-server中 HMR 模块的热更新：\n\n **注意事项：** \n1. HMR需要新增一些代码，用来手动处理JS模块的热替换、图片模块热替换等（因为不同的业务场景需要处理的数据不同）。\n2. HMR新增代码与业务无关，所以会增加一定工作量；而且写起来比较麻烦，建议结合框架使用完善的HMR方案。\n3. HMR新增代码与业务无关，但是在webpack打包过后其实是删除了的，对生产环境没有影响。\n\n\n **使用场景：** \n\n1. 在页面中有一个编辑器，在编辑器中输入内容然后再修改样式。webapck-dev-server负责刷新整体页面，如果每次修改了样式后页面刷新，编辑器中的内容就会丢失。HMR插件能实现在页面不刷新的情况下，局部模块的更新。<br>\n2. 在开发过程中频繁修改页面某个模块的样式，例如：背景图片。\n\n\n **如何使用：** \n1. 命令行参数： webpack-dev-server --hot\n2. 配置文件：\n\n```js\n// 1、引入webpack\nconst webpack = require('webpack')\n\n\n// 2、plugins里面添加内置插件：\nplugins: [\n    new webpack.HotModuleReplacementPlugin()\n    ...\n],\n\n// 3、devServer中添加配置项：\n// 注意：在热替换手动处理js热替换，如果报错热替换会启动失败；\n// 注意：使用hotOly，热替换失败也不会自动刷新页面。\ndevServer: {\n    // 可能出现的错误1：处理的热替换模块有错误，使用hotOnly配置\n    // hot: true,  // 模块热替换，如果热替换失败就自动回到页面自动刷新\n    hotOnly: true, // 模块热替换，如果热替换失败不会自动刷新页面便于定位问题\n    ...\n}\n\n```\n\n **处理JS模块的热替换** \n\n1. webpack中的热替换api：module.hot.accept 用于注册模块处理函数\n\n\n2. 示例场景：修改编辑器模块代码后，热更新编辑器模块\n\n```js\n// 可能出现的错误2：plugins没有开启配置会报错，需要在热替换代码中对module.hot进行判断\nif (module.hot) {\n  let lastEditor = editor\n\n  // 1、编辑器的热替换\n  // 参数1：模块\n  // 参数2：处理函数 => 实现的功能：简单来说就是用js代码更新一下模块内需要更新的内容（重要），例如下面更新了编辑器。\n  module.hot.accept('./editor', () => {\n\n    //移除原来编辑器，记录数据\n    const value = lastEditor.innerHTML\n    document.body.removeChild(lastEditor) \n\n    //更新原来的数据到新的编辑器\n    const newEditor = createEditor()\n    newEditor.innerHTML = value\n    document.body.appendChild(newEditor)\n    lastEditor = newEditor\n  })\n\n  // 2、图片的热替换\n  module.hot.accept('./better.png', () => {\n    img.src = background\n    console.log(background)\n  })\n}\n```\n\n3. 可能出现的错误：\n- 可能出现的错误1：处理的热替换模块有错误，使用hotOnly配置\n- 可能出现的错误2：plugins没有开启配置会报错，需要在热替换代码中对module.hot进行判断\n\n\n  **处理图片模块的热替换** \n```js\n  // 2、图片的热替换\n  module.hot.accept('./better.png', () => {\n    img.src = background\n    console.log(background)\n  })\n```\n\n **VUE + HMR 方案** \n\n参考：[自己网上找]()\n\n **REACT + HMR 方案** \n\n参考：[自己网上找]()\n\n\n\n\n\n\n## 4.3、配置Source Map （便于查看调试代码）\n记录代码转换前后的映射关系\n\n#### Source Map配置方案\n **webpack中的devTool，按照以下3中规则配置：** \n1. eval                  => 使用eval执行模块代码，没有生成对应的.map文件；只能看到错误对应的文件名称；\n2. source-map            => 包含错误的行列信息\n3. cheap                 => 不包含错误的列信息\n4. module                => 不要loader处理源码\n5. inline                => 将.map文件以data-url的形式生成放到url中，很占体积\n\n\n **带eval不生成.map文件：** \n- eval：构建速度最快，只能定位错误文件是哪个；\n- eval-source-map：错误文件名称 + 错误的行列；\n- cheap-eval-source-map：错误文件名称 + 错误的行；\n- cheap-module-eval-source-map：错误文件名称 + 错误的行 + 代码未被loader处理；\n\n\n **不带eval都生成了.map文件：** \n- source-map：错误文件名称 + 错误的行列；\n- cheap-source-map：错误文件名称 + 错误的行 + 代码未被loader处理；\n- hidden-source-map：代码中看不见source-map源码（适合开发第三方工具，需要的时候再使用）；\n- nosources-source-map：看不到源码，只能看到错误行列号（生产环境可以保护源码）；\n\n\n **带inline不生成.map文件，将其放到url中（不推荐使用inline）：** \n- inline-source-map：将source-map以data-url方式嵌入到url中，导致代码体积变大；\n\n\n **最佳实践：**\n \n- 开发模式：eval-cheap-module-source-map//webpack5中这几个单词顺序不能变，前提是：\n> 1、代码每行不超过80字符\n> 2、Loader转换过后代码差异大，所以需要看源码\n> 3、这种模式启动慢，但是重新打包速度快\n> **4、注意：webpack5中对这几个单词顺序有要求，必须是：** \n> - ^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$\n> - eval-cheap-module-source-map => ok\n> - cheap-module-eval-source-map => old这种就会报错\n\n- 生产模式：none、nosources-source-map\n> 1、这样可以避免暴露源码\n\n\n## 4.4、配置路径别名\n```js\nalias: {\n    '@': resolve('src'),\n    '@config': resolve('config')\n}\n```\n\n\n## 4.5、配置涉及到的路径：publicPath （未完待续，待整理）\n- __dirname\n- process.cwd()\n- path.join(__dirname, 'dist')\n- path.resolve(__dirname, 'dist')\n- './dist'\n- '/dist/'\n\n```js\n// ...\n```\n\n\n\n# 5. 生产环境配置\n## 5.1 根据环境添加不同的配置\n\n#### 方案1：根据命令行参数判断\n **如何判断环境：** 命令行--env production参数会传递给env；\n```\n> webpack --env production\n```\n\n **接收参数：** \n\nwebpack 除了可以直接导出配置；还可以导出一个function，返回配置：\n```js\nmodule.exports = config\nmodule.exports = (env, args)=> config\n```\n\n1. 命令行webpack --env production参数会传递给function的参数env；\n2. 可以在function中对env环境进行判断：\n\n```js\n// webpack提供了一个函数\n// 参数1：env\n// 参数2：args\n// 返回值：配置项\nmodule.exports = (env, args) => {\n    const config = {\n        //...\n    }\n\n    // env 接受参数：webpack --env production\n    if (env === 'production') {\n        config.mode = 'production'\n        config.devtool = false\n        config.plugins = [\n          ...config.plugins,\n          new CleanWebpackPlugin(),\n          new CopyWebpackPlugin(['public'])\n        ]\n    }\n    \n    return config\n}\n```\n\n#### 方案2：提取公用配置到文件，将配置独立到三个文件：=> 最好用\n\n- 依赖：webpack-merge插件\n\n```\n> npm install webpack-merge --save-dev  => 专业用于合并webpack配置项对象的插件\n```\n\n- 功能：将配置独立到三个文件，prod、dev合并公用配置\n\n```\n> webpack.common.js // 公用配置 \n> webpack.prod.js   // 生产环境\n> webpack.dev.js    // 开发环境\n```\n- 例如单独配置prd环境的js，合并webpack.common.js中的配置\n\n```js\n// 合并配置，比较专业的模块：webpack-merge\n// 合并配置，最好不要用Object.assign，它在复制对象时后面的配置会完全覆盖掉前面的配置\nconst { merge } = require('webpack-merge')\n\nconst common = require('./webpack.common.js')\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\n\nmodule.exports = merge(common, {\n    mode: 'production',\n    plugins: [\n      new CleanWebpackPlugin(),\n      new CopyWebpackPlugin(['public'])\n    ]\n})\n```\n\n\n#### 方案3：plugin：DefinePlugin，向打包文件中注入环境变量在webpack打包时判断\n\n- 依赖：无，webpack内置插件：webpack.DefinePlugin\n- 功能：DefinePlugin插件可以向webpack打包文件中注入js代码直接使用，例如：\n\n```js\nplugins: [\n    new webpack.DefinePlugin({\n      // 值要求的是一个代码片段\n      TEST_URL: 'https://api.example.com'，\n      API_BASE_URL: JSON.stringify('https://api.example.com')\n    })\n  ]\n```\n在源码中使用变量，打包到 bundle.js ==> \n```js\n// console.log(TEST_URL)，注意没有引号，不是字符串\nconsole.log(https://api.example.com)\n\n// console.log(API_BASE_URL)，所以需要JSON.stringify()\nconsole.log('https://api.example.com')\n```\n\n- **DefinePlugin 配合 process.end.NODE_ENV 使用**\n\n1. process.end.NODE_ENV 获取执行环境\n2. process是在nodejs环境中的全局变量，只能在webpack.config.js中使用；\n3. 想要在源码中使用process判断环境，需要使用插件：DefinePlugin将process变量注入到打包文件。\n4. 以下示例，将环境变量注入到源码boudle.js：process.env.NODE_ENV\n\n```js\nnew webpack.DefinePlugin({\n    PRODUCTION: JSON.stringify(true),\n    VERSION: JSON.stringify('0.0.1'),\n    API_BASE_URL: JSON.stringify('https://api.example.com')\n    'process.env': {\n         NODE_ENV: JSON.stringify(process.env.NODE_ENV)\n     }\n});\n```\n\n- **process.end.NODE_ENV使用时的兼容性问题** ，在npm scripts中添加：\n\nwindows/linux兼容：\n```\ncross-env NODE_ENV=development\n```\nwindows：\n```\nSET NODE_ENV=development\n```\nos x/linux：\n```\nexport NODE_ENV=development\n```\n\n\n\n\n# 6. 优化打包性能\n\n## 6.1 Tree Shaking 功能\n#### 基本使用\n将未使用的代码处理掉，合并模块等功能；没有依赖项。\n\n- 生产环境下自动启用\n- 其他环境下开启配置\n\n```\nmodule.exports = {\n  mode: 'none',\n  entry: './src/index.js',\n  output: {\n    filename: 'bundle.js'\n  },\n  optimization: {\n    // 模块只导出被使用的成员\n    usedExports: true,\n    \n    // 压缩输出结果，usedExports开启后会移除未被使用的成员\n    // minimize: true,\n\n    // 尽可能合并每一个模块到一个函数中（Scop Hosting）\n    concatenateModules: true,\n  }\n}\n```\n\n\n#### Tree Shaking和Babel（未完待续）\n据说是用babel时，tree shaking会失效？\n- tree shaking前提是 ESM Modules，由webpack打包的代码必须是用EMS\n- babel preset-env这个插件就是将es6+转换为es5，而且它是将ESM => 转换为CommonJS的方式，导致tree shaking失效（Babel到底是将什么ESM转换为CommonJS，待梳理~~~~~~~~~~~）\n- 最新版本的Babel自动关闭了 ESM 转换插件，ESM并没有转换；所以tree shaking可以正常工作。\n\n```js\n    rules: [\n      {\n        test: /\\.js$/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: [\n              // 如果 Babel 加载模块时已经转换了 ESM，则会导致 Tree Shaking 失效；最新版本的Babel自动关闭了 ESM 转换插件\n              // ['@babel/preset-env', { modules: 'commonjs' }] // 强制将ESM转换为CommonJS，tree shaking失效\n              // ['@babel/preset-env', { modules: false }] // 强制关闭转换插件\n              // 也可以使用默认配置，也就是 auto，这样 babel-loader 会自动关闭 ESM 转换\n              ['@babel/preset-env', { modules: 'auto' }]\n            ]\n          }\n        }\n      }\n    ]\n```\n\n#### Tree Shaking与sideEffects（未完待续，使用场景待研究）\n **sideEffects使用场景：** \n\n如果有定义了很多模块（例如多个组件），但实际上只使用了一个；打包的时候需要删除多余的代码，可以用sideEffects配置。\n\n- 生产环境下自动启用\n- 开发环境下如下配置\n\n\n **sideEffects配置**\n \nwebpack.config.js 下的配置\n```js\n  // webpack.config.js 下的配置\n  optimization: {\n    sideEffects: true,//打开移除未使用的模块\n  }\n```\n\npackage.json下的配置：\n```js\n// package.json的配置和webpack下的配置意义不同，此处只是标识代码没有副作用\n\"sideEffects\": false // 标识代码没有副作用，webpack在打包时会删掉有副作用的代码\n```\n\n## 6.2 多入口打包 => 解决文件过大的问题\n#### 方案1：多个html-webpack-plugin\n- 依赖：\n\n```\n> npm install html-webpack-plugin --save-dev\n```\n- 功能：\nentry 定义多个入口并使用多个 HtmlWebpackPlugin() 插件；具体参考示例源码；\n\n\n#### 方案2：使用auto-web-plugin插件按照目录生成html\n- 依赖：\n\n```\n> npm install auto-web-plugin --save-dev\n```\n- 功能：（未完待续）\n\n```js\n// ...\n```\n\n## 6.3 CodeSplit代码分片，按需加载 => 解决文件过大的问题\n- 依赖：无\n- 功能：使用动态加载语句：import('./components/banner.js').then(banner => {})\n- 实践：通常和路由相结合，不需要其他配置\n\n```js\n\nconst render = () => {\n  const hash = window.location.hash || '#posts'\n  const mainElement = document.querySelector('.main')\n  mainElement.innerHTML = ''\n\n  if (hash === '#posts') {\n    // mainElement.appendChild(posts())\n    // /* webpackChunkName: 'components' */为魔法注释，可用将两个模块合并到同一个文件名中\n    import(/* webpackChunkName: 'components' */'./posts/posts').then(({ default: posts }) => {\n      mainElement.appendChild(posts())\n    })\n  } else if (hash === '#album') {\n    // mainElement.appendChild(album())\n    import(/* webpackChunkName: 'components' */''./album/album').then(({ default: album }) => {\n      mainElement.appendChild(album())\n    })\n  }\n}\n\nrender()\n\nwindow.addEventListener('hashchange', render)\n```\n\n- 配合VUE-ROUTER示例：（未完待续）\n\n```js\nconst routes = [\n  {\n    path: '/',\n    name: 'Index',\n    component: Index\n  },\n  {\n    path: '/detail/:id',\n    name: 'Detail',\n    props: true,\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () => import(/* webpackChunkName: \"detail\" */ '../views/Detail.vue')\n  }\n]\n```\n\n## 6.4 splitChunks，提取js公共代码\n- 依赖：无，直接在optimization中配置\n- 功能：取代了webpack4中的CommonsChunkPlugin，默认值是按需加载的 chunks；参考：https://webpack.docschina.org/plugins/split-chunks-plugin/\n\n```js\noptimization: {\n    splitChunks: {\n        // 自动提取所有公共模块到单独 bundle；可选配置有：all，async 和 initial。\n        // 设置为 all 可能特别强大，因为这意味着 chunk 可以在异步和非异步 chunk 之间共享\n        chunks: 'all'\n    }\n},\n```\n\n## 6.5 MiniCssExtractPlugin，提取CSS到单个文件\n- 依赖：\n\n```\n> npm install mini-css-extract-plugin --save-dev             => 将样式存放到单独的css文件中，取代style-loader\n> npm install optimize-css-assets-webpack-plugin --save-dev  => 手动打开css压缩代码\n> npm install terser-webpack-plugin --save-dev               => 手动打开js压缩代码\n```\n- 功能：\n\n1. 将css代码存放到单独的css文件中，是否也可以合并css文件？（待研究：https://webpack.docschina.org/plugins/mini-css-extract-plugin/）\n2. 配合css-loader，不再需要style-loader；\n\n```js\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n// ...\n\n  optimization: {\n    minimizer: [// 使用了minimizer，webpack认为不再启动自动压缩js代码\n      new TerserWebpackPlugin(),            //手动打开js压缩代码\n      new OptimizeCssAssetsWebpackPlugin()  //手动打开css压缩代码\n    ]\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          // 'style-loader', // 将样式通过 style 标签注入\n          MiniCssExtractPlugin.loader, // 将样式存放到单独的css文件中\n          'css-loader'\n        ]\n      }\n    ]\n  },\n  plugins: [\n    ...，\n    new MiniCssExtractPlugin()\n  ]\n```\n\n## 6.6 ExtractTextPlugin、MiniCssExtractPlugin哪个更好用？\n\n1. MiniCssExtractPlugin基于 webpack v4 的新特性（模块类型）构建，并且需要 webpack 4 才能正常工作。\n2. 与 extract-text-webpack-plugin 相比，MiniCssExtractPlugin：\n> https://webpack.docschina.org/plugins/mini-css-extract-plugin/\n- 异步加载\n- 没有重复的编译（性能）\n- 更容易使用\n- 特别针对 CSS 开发\n\n## 6.7 文件名hash，解决缓存带来的问题\n **webpack中有三种hash：** \n1. 项目级别：filename: '[name]-[hash].bundle.js' —— 项目中任何改动都会修改hash\n2. Chunk级别：filename: '[name]-[chunkhash].bundle.js' —— 同一路chunk改动会修改hash\n3. 内容级别：filename: '[name]-[contenthash].bundle.js' —— 文件发生变化时才会改变hash\n\n\n **最佳方案：** 使用contenthash:8，并且后面可以指定位数：8位。\n\n```js\n  output: {\n    filename: '[name]-[contenthash:8].bundle.js'\n  },\n  ...\n  plugins: [\n    ...,\n    new MiniCssExtractPlugin({\n      filename: '[name]-[contenthash:8].bundle.css'\n    })\n  ]\n\n```\n\n\n## 6.8 Happypack：多线程并行打包\nwebpack4 之后推荐使用 thread-loader；而且 happypack 已经没怎么维护了，和 vue-loader 配合也会有一些配置问题；\n\n\n## 6.9 其它提高构建性能的方案\n官方建议：https://webpack.docschina.org/guides/build-performance/\n\n **如何对webpack构建性能进行分析：** \n\n参考文档：https://juejin.cn/post/6911519627772329991\n\n```\n> npm install --save-dev speed-measure-webpack-plugin  => 分析 webpack 打包速度\n> npm install --save-dev webpack-bundle-analyzer       => 分析 webpack 打包模块大小\n```\n **提升构建速度方案（主要的几个）：** \n\n1. 通过使用 include 字段减小打包范围\n2. 使用 DllPlugin 为更改不频繁的代码生成单独的打包文件；配置参考：https://webpack.docschina.org/plugins/dll-plugin/\n3. 多使用分片按需加载功能，SplitChunksPlugin 配置；\n4. 使用 thread-loader，功能类似于happypack；创建多线程打包，配置参考：https://webpack.docschina.org/loaders/thread-loader/#root\n\n```\n1. 请仅在耗时的操作中使用 thread-loader，因为：在 worker 池中运行的 loader 是受到限制的；具体参考文档。\n2. 不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 main process(主进程) 之间的模块传输。进程间通讯(IPC, inter process communication)是非常消耗资源的。\n```\n\n5. 使用配置项：cache，缓存生成的 webpack 模块和 chunk，来改善构建速度。cache 会在开发 模式被设置成 type: 'memory' 而且在 生产 模式 中被禁用。 参考：https://webpack.docschina.org/configuration/other-options/#cache\n6. 开发阶段尽量使用 webpack-dev-server 在内存中构建\n7. 配置 devTool 生成映射文件时选择合适的选项\n8. // ...\n\n# 7. 示例代码\nhttps://gitee.com/ymcdhr/e-demo/tree/master/webpack-sample\n\n# 8. 参考资料：\nhttps://webpack.docschina.org/guides/\nhttps://webpack.docschina.org/guides/build-performance/\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)","published_at":"2021-07-11T18:21:57.780Z","updated_at":"2021-07-12T07:15:26.316Z"}},{"node":{"id":"12","title":"前端工程化5：Gulp最基本配置，10分钟看完就会","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"## Gulp的基本使用\n\n#### 安装\n```js\n> npm install gulp -g\n```\n\ngulp的配置文件：gulpfile.js\ngulp4.0以后不再推荐使用 gulp.task() ，而是推荐使用 exports 的方式定义任务：\n```js\nexports.foo = done =>{\n\n  done() //标记任务完成\n}\n```\n\n#### 组合配置\n```js\nconst { series, parallel } = require('gulp')\n\nconst task1 = done => {\n  setTimeout(() => {\n    console.log('task1 working~')\n    done()\n  }, 1000)\n}\n\nconst task2 = done => {\n  setTimeout(() => {\n    console.log('task2 working~')\n    done()\n  }, 1000)  \n}\n\nconst task3 = done => {\n  setTimeout(() => {\n    console.log('task3 working~')\n    done()\n  }, 1000)  \n}\n\n// 让多个任务按照顺序依次执行\nexports.foo = series(task1, task2, task3)\n\n// 让多个任务同时执行\nexports.bar = parallel(task1, task2, task3)\n```\n\n#### 异步任务\n```js\nconst fs = require('fs')\n\nexports.callback = done => {\n  console.log('callback task')\n  done()\n}\n\nexports.callback_error = done => {\n  console.log('callback task')\n  done(new Error('task failed'))\n}\n\nexports.promise = () => {\n  console.log('promise task')\n  return Promise.resolve()\n}\n\nexports.promise_error = () => {\n  console.log('promise task')\n  return Promise.reject(new Error('task failed'))\n}\n\nconst timeout = time => {\n  return new Promise(resolve => {\n    setTimeout(resolve, time)\n  })\n}\n\n// Nodejs版本在8以上可以使用async、await\nexports.async = async () => {\n  await timeout(1000)\n  console.log('async task')\n}\n\n// 最常用的一种，读写文件\nexports.stream = () => {\n  const read = fs.createReadStream('yarn.lock')\n  const write = fs.createWriteStream('a.txt')\n  read.pipe(write) // 导入文件流\n  return read // 结束任务\n}\n\n// exports.stream = done => {\n//   const read = fs.createReadStream('yarn.lock')\n//   const write = fs.createWriteStream('a.txt')\n//   read.pipe(write)\n//   read.on('end', () => { // 结束任务\n//     done()\n//   })\n// }\n\n```\n\n#### 构建过程核心工作原理\n输入 => 加工 => 输出\n\n```js\nconst fs = require('fs')\nconst { Transform } = require('stream')\n\nexports.default = () => {\n  // 文件读取流\n  const readStream = fs.createReadStream('normalize.css')\n\n  // 文件写入流\n  const writeStream = fs.createWriteStream('normalize.min.css')\n\n  // 文件转换流\n  const transformStream = new Transform({\n    // 核心转换过程\n    transform: (chunk, encoding, callback) => {\n      const input = chunk.toString()\n      const output = input.replace(/\\s+/g, '').replace(/\\/\\*.+?\\*\\//g, '')\n      callback(null, output)\n    }\n  })\n\n  return readStream\n    .pipe(transformStream) // 转换\n    .pipe(writeStream) // 写入\n}\n\n```\n\n#### 文件操作API\n```js\nconst { src, dest } = require('gulp')\nconst cleanCSS = require('gulp-clean-css')\nconst rename = require('gulp-rename')\n\nexports.default = () => {\n  return src('src/*.css')\n    .pipe(cleanCSS()) // 压缩css代码插件\n    .pipe(rename({ extname: '.min.css' })) // 重命名文件插件\n    .pipe(dest('dist'))\n}\n\n```\n\n\n## Gulp基础配置\n\n#### 准备工作\n\n- 安装gulp工具：npm install gulp -g\n- 创建gulp配置：在项目根目录下新建文件gulpfile.js，用于写gulp的配置文件；\n\n\n#### Task：清空文件\n- 功能：清空构件生产的所有文件\n- 依赖：del\n\n```js\nconst clean = () => {\n    return del(['dist','temp'])\n}\n```\n\n#### Task：css文件处理，sass文件转换\n- 功能：将sass文件转换成css文件写入指定目录\n- 依赖：gulp-sass\n\n```js\nconst style = () => {\n    return src('src/assets/styles/*.scss',{ base: 'src'}) // base指定基础目录，转换后dist目录才会和src保持一样的结构\n        .pipe(plugins.sass({ outputStyle: 'expanded'})) // { outputStyle: 'expanded'} 参数可以指定结束括号格式化    \n        .pipe(dest('temp'))\n}\n```\n\n#### Task：js文件处理，编译es6+为es5\n- 功能：使用babel插件将js文件里的es6+代码转换为es5\n- 依赖：\n> 1、gulp-babel => babel工具：转换平台，不作具体的工作\n> 2、@babel/core => babel核心转换模块：完成语言转换工作\n> 3、@babel/preset-env => babel的转换插件：指定babel对应的转换内容；比如env包含es6+全部新特性，将其转换到es5\n\n```js\nconst script = () => {\n    return src('src/assets/scripts/*.js',{ base: 'src'})\n        .pipe(plugins.babel({ \n            presets: ['@babel/preset-env'] // 编译es6，必须传递参数preset-env，否则转换失效(babel配置可以单独放到.babelrc文件)\n        }))\n        .pipe(dest('temp'))\n}\n```\n\n#### Task：html文件的转换，处理swig模板\n- 功能：将指定的swig模板转换为html文件，注意：\n> 1、gulp配置的时候可以将数据以对象的形式传递数据给模板引擎；通常将数据定义在文件中：pages.config.js\n> 2、swig模板的缓存配置可以关闭，防止浏览器在热更新时没有实时刷新\n- 依赖：gulp-swig\n\n```js\nconst page = () => {\n    return src('src/**/*.html',{ base: 'src'}) // 其中/**/*.html表示在src目录下任意子目录下的匹配\n        .pipe(plugins.swig({ data: config.data, defaults: { cache: false } }))   //转换模板页，将data数据传递给模板使用，cache：swig缓存设置，否则热更新时可能不立即生效\n        .pipe(dest('temp'))\n}\n```\n\n#### Task：图片压缩，减少图片体积\n- 功能：压缩图片体积\n- 依赖：gulp-imagemin\n\n```js\nconst image = () => {\n    return src('src/assets/images/**',{ base: 'src'})\n        .pipe(plugins.imagemin())\n        .pipe(dest('dist'))\n}\n```\n\n\n#### Task：字体文件压缩，减少字体文件体积\n- 功能：压缩字体体积\n- 依赖：gulp-imagemin\n\n```js\nconst font = () => {\n    return src('src/assets/fonts/**', { base: 'src' })\n      .pipe(plugins.imagemin())\n      .pipe(dest('dist'))\n}\n```\n\n#### Task：其它文件移动，例如视频\n- 功能：移动其余所有文件到指定目录\n- 依赖：无\n\n```js\nconst extra = () => {\n    return src('public/**', { base: 'public' })\n        .pipe(dest('dist'))\n}\n```\n\n\n\n## Gulp的本地服务/热更新/文件合并与压缩\n#### Task：本地Web服务与热更新\n- 功能1：本地Web服务\n> 1、使用插件browser-sync来启动本地Web服务，并支持一些配置（具体参考示例代码）\n> 2、重要配置：根路径baseDir，配置后gulp从指定的路径按顺序查找\n> 3、重要配置：路径查找路由routes，例如：/node_modules映射到node_modules\n\n- 功能2：浏览器的热更新\n> 在browser-sync插件的配置中使用files: 'temp/**'监视目录下所有文件\n\n- 功能3：源文件的热更新\n> 1、监视源文件，如果源文件修改后立即重新构建\n> 2、开发模式下：监视的范围不包括图片、字体和其它文件，将他们的访问路径指定为src路径下可提升构建效率\n\n- 依赖：browser-sync\n\n```js\nconst serve = () => {\n    // 监视src文件，重新构建代码\n    watch('src/assets/styles/*.scss', style)\n    watch('src/assets/scripts/*.js', script)\n    watch('src/*.html', page)\n\n    // 图片、字体在开发阶段没有必要重新执行构建任务；所以让gulp从源文件src、public里面查找  \n    // 图片、字体等文件发生变化后，bs.reload 更新浏览器\n    watch([\n        'src/assets/images/**',\n        'src/assets/fonts/**',\n        'public/**'\n    ], bs.reload)\n    \n    // 配置web服务器，监视dist\n    bs.init({\n        notify: false, // 右上角提示\n        port: 2080, // 服务的端口，默认300\n        // open: false, // 自动打开浏览器\n        files: 'temp/**', // 热更新，dist下的所有文件变化时，同步更新浏览器\n        server: {\n          //服务启动时，首先访问dist根目录；查询路径：dist=>src=>public\n          //因为图片字体等文件没必要热更新重新构建（减少构建时间），所以让gulp从源文件src、public里面查找  \n          baseDir: ['temp', 'src', 'public'], \n          routes: {// 路径查找路由\n            '/node_modules': 'node_modules' //优先级高于baseDir,先查找node_modules目录\n          }\n        }\n    })\n}\n```\n\n#### Task：文件合并与压缩混淆\n- 功能1：文件合并\n> useref插件查询指定路径，然后将对应的文件合并\n- 功能2：文件压缩\n> 1、压缩js\n> 2、压缩css\n> 3、压缩html\n- 依赖：\n> 1、gulp-useref => 查询路径，合并文件\n> 2、gulp-if => 判断条件插件\n> 3、gulp-uglify => 压缩js\n> 4、gulp-clean-css=> 压缩css\n> 5、gulp-htmlmin => 压缩html\n\n```js\nconst useref = () => {\n    return src('temp/*.html', { base: 'temp' })\n        .pipe(plugins.useref({ searchPath: ['temp', '.'] })) //查询路径：dist、.根目录下（node_modules） \n        // html js css压缩代码\n        .pipe(plugins.if(/\\.js$/, plugins.uglify()))\n        .pipe(plugins.if(/\\.css$/, plugins.cleanCss()))\n        .pipe(plugins.if(/\\.html$/, plugins.htmlmin({\n            collapseWhitespace: true, // 折叠空白字符\n            minifyCSS: true, // 自动压缩style里面的css\n            minifyJS: true // 自动压缩script里面的js\n            // 还有删除注释、空属性等配置\n            // ...\n        })))\n        .pipe(dest('dist'))\n}\n```\n\n## Gulp配置构建任务的类别\n#### 如何组合任务？\n1. 使用parallel/series进行组合任务；\n2. 其中parallel是并行执行，series是串行执行\n\n#### Gulp构建任务的类别\n **1. 基础构建：** 只构建css、js、html便于本地测试\n```js\nconst compile = parallel(style, script, page) \n```\n\n **2. 开发模式：** 基础构建 + 启动web服务 + 热更新（图片/字体等文件使用src本地加快构建速度）\n```js\n// 2、开发模式：只构建各种代码，启动web服务，图片/字体等文件使用src本地加快构建速度\nconst develop = series(clean, compile, serve)\n```\n\n **3. 生产模式：** 执行所有任务；包括合并/压缩各种文件，然后将图片/文件也处理了\n```js\nconst build = series(\n    clean, \n    parallel(\n        series(compile, useref), \n        extra, \n        image, \n        font\n    )\n)\n```\n\n## 其它配置，简化配置、提升自定义程度\n#### 1、自动加载全部的plugin\n- 功能：避免引入太多常用插件，直接使用plugins替代；例如：需要将sass替换为plugins.sass变量。\n- 依赖：gulp-load-plugins\n\n```js\n// const sass = require('gulp-sass') // npm install gulp-sass --save-dev\n// ==>\n// 自动加载全部的plugin；例如sass，使用plugins.sass替换即可\nconst loadPlugins = require('gulp-load-plugins') // npm install gulp-load-plugins --save-dev\nconst plugins = loadPlugins() \n```\n\n将原始变量替换为plugins.xxx属性\n```js\n.pipe(sass({ outputStyle: 'expanded'}))\n// ==>\n.pipe(plugins.sass({ outputStyle: 'expanded'}))\n```\n\n#### 2、模板数据可配置\n- 功能：\n> 1、将模板引擎所需要的数据定义在：pages.config.js，在gulpfile.js中使用默认配置\n> 2、gulpfile.js中的所有路径可以使用变量替换，实现更高的自定义程度\n- 依赖：无\n\n```js\nlet config = {\n  // default config\n  build: {\n    src: 'src',\n    dist: 'dist',\n    temp: 'temp',\n    public: 'public',\n    paths: {\n      styles: 'assets/styles/*.scss',\n      scripts: 'assets/scripts/*.js',\n      pages: '*.html',\n      images: 'assets/images/**',\n      fonts: 'assets/fonts/**'\n    }\n  }\n}\n\ntry {\n  const loadConfig = require(`${cwd}/pages.config.js`)\n  config = Object.assign({}, config, loadConfig)\n} catch (e) {}\n```\n\n- 数据文件：pages.config.js\n\n```js\nmodule.exports = {\n  build: {\n    src: 'src',\n    dist: 'release',\n    temp: '.tmp',\n    public: 'public',\n    paths: {\n      styles: 'assets/styles/*.scss',\n      scripts: 'assets/scripts/*.js',\n      pages: '*.html',\n      images: 'assets/images/**',\n      fonts: 'assets/fonts/**'\n    }\n  },\n  data: {\n    menus: [\n      {\n        name: 'Home',\n        icon: 'aperture',\n        link: 'index.html'\n      },\n      ...\n    ],\n    pkg: require('./package.json'),\n    date: new Date()\n  }\n}\n```\n\n\n\n\n\n\n\n## 配置Npm Scripts，启动构建任务：\n\n#### 1、导出任务：在gulpfile.js文件中exports \n```js\nmodule.exports = {\n    clean,\n    build,\n    develop\n}\n```\n#### 2、配置scripts：在文件package.json中配置对应任务执行脚本\n```js\n  \"scripts\": {\n    \"clean\": \"gulp clean\",\n    \"build\": \"gulp build\",\n    \"develop\": \"gulp develop\"\n  },\n```\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)\n\n\n","published_at":"2021-07-11T18:21:27.186Z","updated_at":"2021-07-12T07:15:26.316Z"}},{"node":{"id":"11","title":"前端工程化4：如何去做js模块化开发？ES Modules/CommonJS有什么区别？","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"\n## 1. 如何去做js模块化开发 => 模块化标准 + 加载器\n1.1、我们说讨论的仅限于javascript代码的模块化，如果要涉及到所有文件的模块化请使用webpack。\n1.2、那么js的模块化可以用一句话概括：模块化标准 + 加载器；本文主要介绍模块化标准。\n \n## 2. 几种模块化标准对比：\n\n#### CommonJS\n1、以同步的模式加载模块：通常在Nodejs环境使用，不适合浏览器\n```\n1. 因为服务器读本地磁盘文件会比较快，所以nodejs的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；\n2. 如果在浏览器端代码执行时去同步require很多模块，也会影响页面执行效率。\n```\n2、一个文件就是一个模块，且每个模块都有单独的作用域；因为模块输出的是一个值的浅拷贝。\n3、require(模块)加载的是一个对象，该对象是运行时生成；\n4、导入导出\n```js\n// 导出\nmodule.exports = {\n    name: 'wangyi',\n    age: 18\n}\n\n// 导入\nconst { name, age } = require('./module.js')\n```\n\n#### ES Modules\n1、以异步的模式加载模块：支持Nodejs环境使用，也适合浏览器（ES6以上才支持的规范，存在兼容性问题，最好配合 webpack 进行加载）；\n2、ES Modules的导入导出是固定用法，输出的是值的只读引用（原始值变了，取值跟着变）；\n3、ES Modules的导入导出不是对象而是对外接口，该接口在代码编译时就完成，执行效率更高\n4、导入导出\n```js\n// 注意：此处是固定用法，export 后面不是对象；export default 后面才是对象\n\n// 导出1\nexport { name, age }\n// 导入1\nimport { name, age } from './module.js'\n\n// 导出2\nexport default { name, age }\n// 导入2\nimport module from './module.js'\nconst { name, age } = module\n```\n\n#### AMD + require.js\n1、以异步的方式加载模块，可以指定回调函数；\n2、AMD规范配合require.js库作为加载器使用；\n3、目前绝大多数第三方库都支持AMD\n4、使用起来比较复杂\n5、模块js文件请求频繁，因为每个模块都会创建一个script标签去请求文件\n6、导入导出\n```js\ndefine('module1', ['jquery', './module2'], function($, module2){\n  return {\n    // 可以在里面使用依赖的 $、module2 模块\n  }\n})\n```\n\n#### CMD + sea.js\nCMD规范配合sea.js库作为加载器使用，实现了模块化开发（淘宝）；后来sea.js被require.js兼容了，便不再使用。\n\n\n\n\n\n\n## 3. 模块化标准使用最佳实践\n#### 3.1、Nodejs环境 => CommonJS\n3.1.1、因为服务器读本地磁盘文件会比较快，所以 nodejs 的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；\n3.1.2、如果在浏览器端代码执行时去同步 require 很多模块，也会影响页面执行效率。\n3.1.3、module 对象是在 Nodejs环境定义的，配合 require 函数使用；如果说谁是 CommonJS 的加载器，那就是 Nodejs环境。\n\n#### 3.2、浏览器端 => ES Modules + Webpack\n3.2.1、因为浏览器端会有很多的异步加载且当前的ES6开发比较简单，所以浏览器端适合使用ES Modules。\n3.2.2、ES Modules 通常经过 webpack + babel 进行转换；将其转换成立即执行函数的方式，以此来模仿块级作用域；（webpack 也支持在源码中使用 CommonJS 和 ESM 互相导入导出，但一般不用）\n3.2.3、因为 webpack 是在 nodejs 环境运行，所以其配置文件通常使用 CommonJS 规范。\n3.2.4、因为 ES Modules 通常需要配合打包工具进行使用，所以 webpack 可以算得上它的加载器。\n\n\n## 4. ES Module 基本使用知识点\n\n **4.1、ES Modules虽然是ES6才出现的规范，但是未来浏览器原生支持**\n \n **4.2、ES Modules支持在script标签上直接定义使用：** \n4.2.1. ESM 自动采用严格模式，忽略 'use strict'\n4.2.2. 每个 ES Module 都是运行在单独的私有作用域中\n4.2.3. ESM 是通过 CORS 的方式请求外部 JS 模块的\n4.2.4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>ES Module - 模块的特性</title>\n</head>\n<body>\n  <!-- 通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 -->\n  <script type=\"module\">\n    console.log('this is es module')\n  </script>\n\n  <!-- 1. ESM 自动采用严格模式，忽略 'use strict' -->\n  <script type=\"module\">\n    console.log(this)\n  </script>\n\n  <!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 -->\n  <script type=\"module\">\n    var foo = 100\n    console.log(foo)\n  </script>\n  <script type=\"module\">\n    console.log(foo)\n  </script>\n\n  <!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的 -->\n  <!-- <script type=\"module\" src=\"https://unpkg.com/jquery@3.4.1/dist/jquery.min.js\"></script> -->\n\n  <!-- 4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果 -->\n  <script type=\"module\" src=\"demo.js\"></script>\n  <p>需要显示的内容</p>\n</body>\n</html>\n```\n\n **4.3、ES Modules 的 export和 import：** \n- 导出：\n - export { } 后面不是一个对象，而是固定用法 { XXX }，import { sss } from module也是固定用法，不是解构语法；export default { } 后面才可以跟一个对象、字符串等都行。\n - export 导出的是一个引用关系，而且是只读的！不是深拷贝的对象。\n\n```js\nvar name = 'foo module'\n\nfunction hello () {\n  console.log('hello')\n}\n\nclass Person {}\n\nexport { \n  name as foo, \n  hello, \n  Person \n}\n```\n\n- 导入（导入路径必须完整）：\n - 文件名称必须完整，不能省略.js、/index.js；\n - 相对路径也必须完整，不能省略./；\n - 可以绝对路径或者完整的url\n\n> import不支持动态导入，需要使用import().then()\n```js\nimport { foo, hello, Person } from './module.js'\nconsole.log(name, hello, Person)\n\n// 只加载模块不提取模块变量，可以简写：import './module.js'\nimport {} from './module.js'\nimport './module.js'\n\n// 导入模块内的全部变量\nimport * as mod from './module.js'\nconsole.log(mod)\n\n// 动态导入\nimport('./module.js').then(function (module) {\n  console.log(module)\n})\n```\n\n\n\n **4.4、ES Modules 的 export default**\n- export default 后面可以跟对象、字符串等类型\n- export 过后可以继续添加 export default \n- import 的第一个位置默认对应export default 导出的值\n\n```js\n// module.js\nvar name = 'jack'\nvar age = 18\n\nexport { name, age }\nconsole.log('module action')\nexport default 'default export'\n```\n\n```js\n// import.js\n// import { name, age, default as title } from './module.js'\n// abc 为 export default 导出值的重命名，abc 后面的 { } 不是对象解构，而是固定用法\n// import abc from './module.js'\nimport abc, { name, age } from './module.js'\nconsole.log(name, age, abc)\n```\n\n **4.5、ES Modules 的浏览器兼容**\nIE基本不兼容ES Modules\n\n插件 browser-es-module-loader 用于兼容ES Modules（开发阶段可用，不建议生产环境使用）\n1、在html中直接使用，参考：[npm官方地址](https://www.npmjs.com/package/browser-es-module-loader)\n\n```js\n// 该方法需要动态的去解析脚本执行ESM，性能差！只能在开发阶段使用。\n// script加上nomodule 属性，避免在支持ESM的浏览器上执行两次\n// babel-browser-build.js为babel的运行环境（浏览器端）\n<script nomodule src=\"dist/babel-browser-build.js\"></script>\n// ES Modules把代码读出来交给babel转换\n<script nomodule src=\"dist/browser-es-module-loader.js\"></script>\n \n<!-- script type=module loading -->\n<script nomodule  type=\"module\" src=\"path/to/module.js\"></script>\n\n...\n```\n\n2、npm中使用，估计还是作为依赖资源动态解析ESM（不建议使用）\n```\nnpm install browser-es-module-loader --save-dev\n```\n\n\n\n **4.6、ES Modules 的NodeJS支持情况（8.5+版本）**\nNodeJS 8.5以上的版本支持ES Modules，但是还是实验版本；\n```js\n// 第一，将文件的扩展名由 .js 改为 .mjs；（nodejs 12.10版本以上不需要修改文件名了）\n// 第二，启动时需要额外添加 `--experimental-modules` 参数；\n\nimport { foo, bar } from './module.mjs'\n\nconsole.log(foo, bar)\n\n// 此时我们也可以通过 esm 加载内置模块了\nimport fs from 'fs'\nfs.writeFileSync('./foo.txt', 'es module working')\n\n// 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员方式\nimport { writeFileSync } from 'fs'\nwriteFileSync('./bar.txt', 'es module working')\n\n// 对于第三方的 NPM 模块也可以通过 esm 加载\nimport _ from 'lodash'\n_.camelCase('ES Module')\n\n// 不支持，因为第三方模块都是导出默认成员\n// import { camelCase } from 'lodash'\n// console.log(camelCase('ES Module'))\n\n```\n\n\n\n\n\n **4.7、ES Modules 和CommonJS相互使用（在NodeJS环境中）**\n\n- ESM 中可用导入CommonJS\n- CommonJS中不能导入ESM\n- CommonJS始终只会导出一个默认成员\n- import不是解构导出对象，只能：import mod from './commonjs.js'\n\n\n\n **4.8、ES Modules 和CommonJS的差异（在NodeJS环境中）**\n```js\n// nodejs、CommonJS，文件名为：mjs\n// 加载模块函数\nconsole.log(require)\n\n// 模块对象\nconsole.log(module)\n\n// 导出对象别名\nconsole.log(exports)\n\n// 当前文件的绝对路径\nconsole.log(__filename)\n\n// 当前文件所在目录\nconsole.log(__dirname)\n\n```\n\n```js\n// nodejs、ES Modules，文件名为：mjs\n// require, module, exports 自然是通过 import 和 export 代替\n\n// __filename 和 __dirname 通过 import 对象的 meta 属性获取\n// const currentUrl = import.meta.url\n// console.log(currentUrl)\n\n// 通过 url 模块的 fileURLToPath 方法转换为路径\nimport { fileURLToPath } from 'url'\nimport { dirname } from 'path'\nconst __filename = fileURLToPath(import.meta.url)\nconst __dirname = dirname(__filename)\nconsole.log(__filename)\nconsole.log(__dirname)\n```\n\n## 5. Webpack 基于所有资源去做模块化\n完整的讲解参考后续文章：待续；\n\n5.1、支持新特性语言版本的编译\n5.2、针对javascript模块化打包\n5.3、针对所有资源，例如样式、图片、字体等进行模块化\n\n对于1、2两点，grunt、gulp等脚手架可以很好的解决，但是无法解决第3点。\n\n## 6、Rollup：专门针对ES Modules进行打包的轻量化工具 \n- webpack 大而全 => 适合做大型应用程序\n- rollup 小而美 => 适合做类库\n\n\n## 7、Parcel：零配置专用打包器，简单易用\n\n\n## 8、参考资料：\n[ES6-模块与-CommonJS-模块的差异](https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82)\n\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)","published_at":"2021-07-11T15:03:27.212Z","updated_at":"2021-07-12T07:15:26.316Z"}},{"node":{"id":"10","title":"前端工程化3：如何编写一个Nodejs Cli应用/自定义脚手架","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"## 什么是Nodejs Cli应用？\n简单来说就是在命令行可以使用nodejs来执行的应用，例如：vue-cli、creat-react-app、webpack-cli等；在前端开发过程中我们会用到很多的工具，这些工具在安装过后可以直接使用命令行执行；注意在全局安装和在项目安装不同。\n```\n// 全局安装，直接执行命令\n> npm install webpack webpack-cli -g\n> webpack\n\n// 项目安装，需要借助npx执行\n> npm install webpack webpack-cli --save-dev\n> npx webpack\n```\n\n## Nodejs Cli应用的工作流程！\n\n**1、启动过程：**\n\n命令行执行命令 => 根据package.json中bin查询入口 => 执行入口js文件cli.js\n\n**2、执行过程：**\n\n命令行执行js文件功能启动=> 命令行询问用户问题 => 结合问题答案+模板等文件 => 生成结构文件\n\n\n## Nodejs Cli应用的入口文件：cli.js\n\n **1、入口文件路径** ，首先在package.json 中添加bin字段\n```js\n{\n  \"name\": \"ncl\",\n  \"main\": \"index.js\",\n  \"bin\": {\n    \"ncl\": \"./cli.js\"   //入口文件，ncl和name保持一致\n  },\n  ...\n}\n```\n\n **2、入口文件特定的文件头** ，在cli.js顶部输入\n```js\n#!/usr/bin/env node\n```\n\n **3、入口文件权限** \n// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755\n// 具体就是通过 chmod 755 cli.js 实现修改\n\n **4、简单测试模块** \nnpm link 可以将模块链接到全局，也可以链接到使用该模块的项目node_modules中；这样在开发模块的过程中，不用发布到npm也可以使用模块进行测试。\n```js\n> npm link // 在自定义模块项目的目录执行，将模块连接到全局\n> ncl // 直接执行模块，使用模块名\n```\n\n## Nodejs Cli应用的示例\n该示例的功能实现一个自定义的脚手架：在命令行询问用户一些简单的问题作为参数，然后自动生成一些项目文件。其中的文件可以通过模板生成，也可以传递数据到模板。\n![image.png](/img/bVcS16g)\n\n **1、安装一些依赖模块** \n```js\n> npm install inquirer --save //nodejs环境下，实现命令行的用户交互插件 \n> npm install ejs --save //模板引擎\n```\n\n **2、cli.js中定义命令行询问用户问题**\n- inquire.prompt进行命令行的用户询问操作\n- inquirer.prompt返回值为一个promise对象\n- inquirer.prompt的参数为一个数组\n\n```js\nconst inquirer = require('inquirer')\n\ninquirer.prompt([\n    {\n        type: 'input',\n        name: 'name',\n        message: '请输入项目名称?'\n    }\n])\n.then(anwsers => {\n    // anwsers: { name: \"xxx\" } //anwsers返回一个结果对象\n})\n```\n\n **3、获取模板目录和目标生成目录** \n\n```js\nconst path = require('path')\n\n\n// 模板目录\n// __dirname 获取当前执行代码文件的绝对路径\n// tmplDir 为templates的绝对路径\nconst tmplDir = path.join(__dirname, 'templates')\n\n// 目标目录\n// process.cwd()返回 Node.js 进程的当前工作目录。\n// process参考api文档：http://nodejs.cn/api/process.html\nconst destDir = process.cwd()\n```\n\n **4、模板引擎渲染模板** \n```js\nconst ejs = require('ejs')\nconst path = require('path')\n\n// 通过模板引擎渲染文件\n// 参数1：fileDir为文件的绝对路径\n// 参数2：渲染模板所需变量，存在anwsers对象里面\n// 参数3：回调函数，result为新文件\nejs.renderFile(fileDir, anwsers, (err, result) => {\n  if (err) throw err\n\n  // 将结果写入目标文件路径\n  fs.writeFileSync(fileDestDir, result)\n})\n```\n```\n// 一个package.json作为模板的示例：\n{\n\"name\": \"<%= name %>\",\n  \"version\": \"<%= version %>\",\n  \"description\": \"<%= description %>\",\n  \"author\": \"<%= author %>\",\n  \"bin\": \"cli.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"license\": \"ISC\"\n}\n\n```\n\n **5、读取目录下的文件** \n```js\n  // 将模板下的文件全部转换到目标目录\n  // 参数1：path\n  // 参数2：回调函数，参数files为文件相对路径组成的数组\n  fs.readdir(tmplDir, (err, files) => {\n    if (err) throw err\n    files.forEach(file => {\n      // 通过模板引擎渲染文件\n      // 处理 file \n      })\n    })\n  })\n\n```\n\n **6、将文件写入路径** \n```js\n// 将结果写入目标文件路径\n// 参数1：文件的绝对路径\n// 参数2：文件内容\nfs.writeFileSync(fileDestDir, result)\n```\n\n## 模板文件相关\n这里是根据自己的需求将需要自动生成的文件放到模板目录下，没有变化的或者统一的文件就不需要使用模板引擎。\n**1、模板路径：templates；**\n\n**2、通常将整理好的项目结构整体拷贝到templates下**，例如：vue的示例源文件、lint文件、package.json等等；\n![image.png](/img/bVcS16h)\n\n## 测试模块执行\n本地开发可以使用npm link关联模块目录和依赖此模块的项目node_modules目录；也可以发布到npm源上后直接安装使用模块。\n\n**1、关联模块：**\n```bash\n> cd nodejs-cli-sample //Nodejs Cli应用的目录\n> npm link // 将模块连接到全局\n```\n\n**2、执行模块：**\n```bash\n> cd nodejs-cli-demo // 在项目目录执行模块\n> ncl // 直接执行模块，使用模块名（ncl 是项目nodejs-cli-sample的名称）\n```\n\n## 发布Nodejs Cli应用\n1、可以直接使用npm publish发布到源上\n```bash\n> npm publish --registry=https://registry.xxxx\n```\n2、要考虑到npm源是否有写权限，可以发布到自己公司的npm源上或者yarn源上\n```\n// 淘宝镜像源是只读的，publish不上去\n// 发布到yarn的镜像源之后，使用淘宝镜像源时可以手动同步加快模块下载速度\nyarn publish --registry https://registry.yarnpkg.com/\n```\n\n## 完整示例代码\n**1、NodeJs Cli应用cli.js 入口文件**\n```js\n#!/usr/bin/env node\n\n\n// Node CLI 应用入口文件必须要有这样的文件头\n// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755\n// 具体就是通过 chmod 755 cli.js 实现修改\n\nconst fs = require('fs')    // 文件读写\nconst path = require('path')    // 路径获取\nconst inquirer = require('inquirer')    //命令行用户交互\nconst ejs = require('ejs')  // 模板引擎\n\n\n// 脚手架的工作过程：启动 => 命令行询问用户问题 => 结合问题答案+模板 => 生成结构文件\n\ninquirer.prompt([\n    {\n        type: 'input',\n        name: 'name',\n        message: '请输入项目名称(\\'\\')'\n    },\n    {\n        type: 'input',\n        name: 'version',\n        message: '请输入项目版本号(1.0.0)'\n    },\n    {\n        type: 'input',\n        name: 'description',\n        message: '请输入项目备注(\\'\\')'\n    },\n    {\n        type: 'input',\n        name: 'author',\n        message: '请输入作者名称(\\'\\')'\n    }\n])\n.then(anwsers => {\n    // anwsers: { name: \"xxx\" } //anwsers返回一个结果对象\n\n    // 模板目录绝对路径\n    const tmplDir = path.join(__dirname, 'templates')\n    // 目标目录\n    const destDir = process.cwd()\n\n    // 读取目录下所有文件\n    let readFiles = (dir) => {\n        return new Promise((resolve, reject)=>{\n            // 参数1：目录路径\n            // 参数2：回调函数（错误对象，files为文件相对路径组成的数组）\n            fs.readdir(dir, (err, files) => {\n                if (err) reject(err)\n                resolve(files)\n            })\n        })\n    }\n\n    // 处理模板文件\n    let ejsRender = (file) => {\n        return new Promise((resolve, reject)=>{\n            // 模板文件绝对路径\n            let dir = path.join(tmplDir, file)\n            // 参数1：文件路径\n            // 参数2：数据对象\n            // 参数3：回调函数（错误对象，渲染后的新文件）\n            ejs.renderFile(dir, anwsers, (err, result) => {\n                if (err) reject(err)\n                resolve(result)\n            })\n        })\n    }\n\n\n    // 1、先读取目录下所有文件\n    // 2、使用ejs渲染所有模板\n    // 3、再将新文件写到目标路径\n    readFiles(tmplDir).then((files)=>{\n        files.forEach(file => {\n            ejsRender(file).then((result)=>{\n                // 目标文件绝对路径，file其实是文件相对路径\n                let fileDestDir = path.join(destDir, file)\n                // 将结果写入目标文件路径\n                // 参数1：文件绝对路径\n                // 参数2：渲染后新文件\n                fs.writeFileSync(fileDestDir, result)\n            },throwError)\n        })\n\n    },throwError)\n})\n\n/**\n * 错误处理函数\n * @param {*错误对象} error \n */\nfunction throwError(error){\n    throw error\n}\n```\n\n**2、package.json 示例模板文件，使用的ejs模板引擎**\n```json\n{\n\"name\": \"<%= name %>\",\n  \"version\": \"<%= version %>\",\n  \"description\": \"<%= description %>\",\n  \"author\": \"<%= author %>\",\n  \"bin\": \"cli.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"license\": \"ISC\"\n}\n\n```\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)\n","published_at":"2021-07-11T15:03:08.830Z","updated_at":"2021-07-12T07:15:26.316Z"}},{"node":{"id":"9","title":"前端工程化2：如何理解前端工程化？","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"/uploads/logo_521b3eebb2.jpg"}},"content":"## 1、前端工程化解决的问题\n\n#### 1.1 为什么需要前端工程化？\n前端技术发展更新快，一些大型前端项目需要更系统化、更规范化的去组织开发工作；以此来提高对项目的开发效率，减少维护成本。\n\n例如：\n\n我们做一个电商网站（类似淘宝），它有各种商品页、活动页、详情页、列表页等。它有几个特点：\n1. 每个页面功能高度类似，但还是有一些差别；<br>\n2. 它们之间有很多公共依赖；也有一些公共的接口；<br>\n3. 每个页面都作为一个独立的项目由不同的团队或者个人开发。<br>\n\n这时候为了避免混乱和提升开发效率，就需要有：\n\n1. **统一的开发规范**  => 提高代码质量，减少维护成本\n2. **统一的文件组织结构**  => 清新美观的目录结构，便于定位问题\n3. **统一的的模块依赖**  => 相同依赖直接复用，不需要每次新建项目都copy\n4. **统一的工具配置**  => 相同配置直接复用，发布、打包、上传等工作自动化\n5. **统一的基础代码**  => 相同代码直接复用，不需要每次新建项目都copy\n\n\n#### 1.2 前端工程化解决的问题：\n传统的前端开发方式存在一些问题，为了提升整体开发效率并降低代码维护成本；我们需要实现前端开发工程化，它能解决如下问题：\n\n**1、 传统语言和语法在各端的兼容性不好；**\n> 例如，现在的项目通常都是用es6+或者ts去开发；而一些政企项目中客户（特别是国企的客户）还在用一些老电脑，使用的IE8、IE9、IE10等老的浏览器版本不兼容es6+的执行，需要转换为es5甚至es3到浏览器去执行；\n\n**2、 一些项目无法使用模块化/组件化；**\n> 例如，以前做的一个数据可视化项目中有大量图表组件；这些图表组件的代码量和数量很多，全部一次加载浏览器速度很慢。所以需要考虑图表组件的按需加载，那就需要webpack这样的工具来配合做图表的模块化和组件化。\n\n**3、 重复机械式的工作/重复造轮子；**\n> 工程化时，我们可以将重复代码提取成公用的模块或者库供所有人使用，避免重复造轮子；\n\n**4、 没有代码风格统一、质量保证**\n> 在开发中如果没有统一的代码书写规范，那么会造成项目开发的混乱，会在项目中遗留很多隐性的BUG，也会导致后期项目维护成本升高。所以我们通常使用eslint、csslint等工具来检查代码书写规范。\n\n**5、 前后端分离开发过程中，依赖后端服务支持导致效率低下**\n> 现在的项目开发中，为了提升效率和项目解耦通常采用了前后端分离的方式；但是前端开发和后端开发是同时进行，大概率情况下前端所需后端接口不能及时提供；所以我们需要使用mock等工具自己去模拟接口。\n\n\n\n\n## 2、前端工程化流程\n\n创建项目 => 编码 => 预览/测试 => 提交 => 部署\n\n![](/img/bVcSWdu)\n\n#### 2.1 创建项目 \n在项目开发初期，我们可以实用工具自动创建一些脚手架、模板、通用等文件；还能够创建项目结构、创建特定类型文件，例如：\n- 创建vue项目：vue-cli\n- 创建react项目：create-react-app\n- 自定义nodejs cli应用：根据自己需求实现的工具，可以自定义创建项目、生成项目描述文件等。\n\n\n#### 2.2 编码\n在正式堆代码的时候，可能会有多人协同开发的场景；这时候需要我们制定编码规范来约束开发人员的编码风格，并使用工具来代替人为约定。除此之外，还可以使用一些自动化工具来替我们自动构建、自动编译打包。\n- 格式化代码：prettier\n- 校验代码风格：eslint、stylelint\n- 编译/构建/打包/模块化：grunt、gulp、fis3、webpack、babel\n\n\n#### 2.3 预览/测试\n在开发本地调试的时候，我们可以使用一些工具来模拟服务器场景并实现热更新、热加载；即代码修改后自动编译构建，浏览器根据变化自动刷新同时还要方便我们查看源码。\n- 本地服务：WebServer / Mock\n- 热加载/热更新：Live Reloading / HMR\n- 源码映射：Source Map\n\n\n#### 2.4 提交\n- Git Hooks：可在提交前进行代码质量和风格的检查\n- Lint-staged\n- 持续集成\n\n\n#### 2.5 部署\n- 自动化部署：CI/CD \n- 自动化集成：Jenkins 可以调用执行脚本，集成自动化构建、打包、部署等\n\n\n## 3、常用的通用脚手架工具\n **vue-cli** —— 创建vue项目的工具\n **create-react-app** —— 创建react项目的工具\n **Yeoman** —— 用于创建自定义脚手架的工具\n **Plop** —— 用于项目中，重复创建相同类型的项目文件（例如vue中某个组件的js、css文件）\n\n\n## 4、常用的自动化构建工具\nGrunt\n- 插件完善\n- 构建速度慢（每一步都有临时文件读写，步骤越多）\n\nGulp\n- 插件完善\n- 构建速度更快（没有临时文件，基于内存实现）\n- 默认支持多个任务同时执行\n- 使用方式更直观易懂\n\nFis \n- 百度开源项目\n- 大而全的构建工具，集成度高一些\n\nWebpack\n- 准确说是模块打包工具，也可以完成自动化构建的功能\n\n## 5、开发阶段实践方案\n例如：我们要开发一个大型的vue项目，最基本的前端开发工程化需要如下工作：\n\n####5.1. 创建项目\n1. 自定义一个nodejs cli应用并发布到npm上（方法见后续文章）\n2. 使用nodejs cli应用创建一个项目，会生成源码目录结构、模板文件、公用文件、构建工具配置等，例如：package.json、webpack.config.js、eslint.lrc等\n3. 使用nodejs cli应用自动调用npm install等工作（可选）\n\n####5.2 编码\n1. 使用webpack进行构建，通过插件babel转换es6+、sass/less、vue模板代码等\n2. 使用webpack配合ES Modules/CommJS规范进行模块化开发\n3. 使用eslint、stylelint进行代码规范检查\n4. 使用prettier进行代码格式化\n\n####5.3 预览/测试\n1. 使用browser-sync、webpack-dev-server作为本地web服务，并进行热更新热加载\n2. 使用webpack配置的source map来调试源码\n3. 使用webpack配置的proxy、Nginx代理来解决跨域问题\n4. 使用mock模拟web服务器的http接口\n\n####5.4 提交\n1. 使用git + github做代码管理（其它gitee或者自己搭的仓库也可）\n2. 结合npm scripts、git hooks、lint-staged在提交代码前进行代码规范检查\n\n####5.5 部署\n1. 使用Jinkens调用命令行进行webpack打包，然后执行一系列后续操作\n2. 然后配合其它的工具可自动发布到我们需要的系统上去（根据公司需求可自定义）\n\n[特别鸣谢：拉勾教育前端高薪训练营](https://kaiwu.lagou.com/)\n","published_at":"2021-07-11T15:02:50.804Z","updated_at":"2021-07-12T07:15:26.316Z"}}]}},"context":{}}