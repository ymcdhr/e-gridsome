<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>首页 - Grdsome 博客</title><meta name="gridsome:hash" content="87002c5fa157b6e786d19711f6bffff4b0d9c799"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/8.styles.8d7e1c32.css" as="style"><link rel="preload" href="/assets/js/app.aa04e74c.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-blog-vue.a3da5a2e.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.0ddd1ab5.js"><link rel="prefetch" href="/assets/js/page--src-templates-blog-list-vue.8a24ccb4.js"><link rel="prefetch" href="/assets/js/page--src-templates-new-vue.8b4559ca.js"><link rel="prefetch" href="/assets/js/page--src-templates-project-list-vue.ba063837.js"><link rel="prefetch" href="/assets/js/page--src-templates-project-vue.7a542983.js"><link rel="prefetch" href="/assets/js/page--src-templates-social-vue.3a209dab.js"><link rel="stylesheet" href="/assets/css/8.styles.8d7e1c32.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div id="app" data-server-rendered="true" class="layout"><header class="header" style="background-image:;"><div class="cover"></div><div class="user"><div class="el-image"><div class="el-image__placeholder"></div><!----></div><div class="name"></div><div class="description"></div></div></header><content class="content"><section class="el-container box is-vertical"><header class="el-header header" style="height:60px;"><div class="el-row"><div class="el-col el-col-24"><a><button type="button" class="el-button el-button--default"><!----><i class="el-icon-edit"></i><span>修改文章</span></button></a></div></div></header><section class="el-container cnt"><aside class="el-aside aside" style="width:200px;"><ul role="menubar" class="menu el-menu" style="background-color:;"><a href="/new?username=undefined"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-menu"></i><span>最新动态</span></li></a><a href="/blog-list"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-notebook-2"></i><span>博客列表</span></li></a><a href="/social"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-bangzhu"></i><span>关注账号</span></li></a><a href="/project-list"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-orange"></i><span>我的项目</span></li></a></ul></aside><main class="el-main main"><div class="article"><div class="markdown-title"><div class="title">
            前端工程化4：如何去做js模块化开发？ES Modules/CommonJS有什么区别？
        </div><div class="el-divider el-divider--horizontal"><!----></div><div class="time"><div class="updated">更新时间：2021/7/12</div><div class="published">发布时间：2021/7/11</div></div></div><div class="markdown-cnt"><!----><div class="cnt"><!----><div class="markdown-here-wrapper"><h2>1. 如何去做js模块化开发 =&gt; 模块化标准 + 加载器</h2>
<p>1.1、我们说讨论的仅限于javascript代码的模块化，如果要涉及到所有文件的模块化请使用webpack。
1.2、那么js的模块化可以用一句话概括：模块化标准 + 加载器；本文主要介绍模块化标准。</p>
<h2>2. 几种模块化标准对比：</h2>
<h4>CommonJS</h4>
<p>1、以同步的模式加载模块：通常在Nodejs环境使用，不适合浏览器</p>
<pre><code>1. 因为服务器读本地磁盘文件会比较快，所以nodejs的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；
2. 如果在浏览器端代码执行时去同步require很多模块，也会影响页面执行效率。
</code></pre>
<p>2、一个文件就是一个模块，且每个模块都有单独的作用域；因为模块输出的是一个值的浅拷贝。
3、require(模块)加载的是一个对象，该对象是运行时生成；
4、导入导出</p>
<pre><code class="language-js"><span class="hljs-comment">// 导出</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;wangyi&#x27;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
}

<span class="hljs-comment">// 导入</span>
<span class="hljs-keyword">const</span> { name, age } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>)
</code></pre>
<h4>ES Modules</h4>
<p>1、以异步的模式加载模块：支持Nodejs环境使用，也适合浏览器（ES6以上才支持的规范，存在兼容性问题，最好配合 webpack 进行加载）；
2、ES Modules的导入导出是固定用法，输出的是值的只读引用（原始值变了，取值跟着变）；
3、ES Modules的导入导出不是对象而是对外接口，该接口在代码编译时就完成，执行效率更高
4、导入导出</p>
<pre><code class="language-js"><span class="hljs-comment">// 注意：此处是固定用法，export 后面不是对象；export default 后面才是对象</span>

<span class="hljs-comment">// 导出1</span>
<span class="hljs-keyword">export</span> { name, age }
<span class="hljs-comment">// 导入1</span>
<span class="hljs-keyword">import</span> { name, age } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>

<span class="hljs-comment">// 导出2</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> { name, age }
<span class="hljs-comment">// 导入2</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable language_">module</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>
<span class="hljs-keyword">const</span> { name, age } = <span class="hljs-variable language_">module</span>
</code></pre>
<h4>AMD + require.js</h4>
<p>1、以异步的方式加载模块，可以指定回调函数；
2、AMD规范配合require.js库作为加载器使用；
3、目前绝大多数第三方库都支持AMD
4、使用起来比较复杂
5、模块js文件请求频繁，因为每个模块都会创建一个script标签去请求文件
6、导入导出</p>
<pre><code class="language-js"><span class="hljs-title function_">define</span>(<span class="hljs-string">&#x27;module1&#x27;</span>, [<span class="hljs-string">&#x27;jquery&#x27;</span>, <span class="hljs-string">&#x27;./module2&#x27;</span>], <span class="hljs-keyword">function</span>(<span class="hljs-params">$, module2</span>){
  <span class="hljs-keyword">return</span> {
    <span class="hljs-comment">// 可以在里面使用依赖的 $、module2 模块</span>
  }
})
</code></pre>
<h4>CMD + sea.js</h4>
<p>CMD规范配合sea.js库作为加载器使用，实现了模块化开发（淘宝）；后来sea.js被require.js兼容了，便不再使用。</p>
<h2>3. 模块化标准使用最佳实践</h2>
<h4>3.1、Nodejs环境 =&gt; CommonJS</h4>
<p>3.1.1、因为服务器读本地磁盘文件会比较快，所以 nodejs 的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；
3.1.2、如果在浏览器端代码执行时去同步 require 很多模块，也会影响页面执行效率。
3.1.3、module 对象是在 Nodejs环境定义的，配合 require 函数使用；如果说谁是 CommonJS 的加载器，那就是 Nodejs环境。</p>
<h4>3.2、浏览器端 =&gt; ES Modules + Webpack</h4>
<p>3.2.1、因为浏览器端会有很多的异步加载且当前的ES6开发比较简单，所以浏览器端适合使用ES Modules。
3.2.2、ES Modules 通常经过 webpack + babel 进行转换；将其转换成立即执行函数的方式，以此来模仿块级作用域；（webpack 也支持在源码中使用 CommonJS 和 ESM 互相导入导出，但一般不用）
3.2.3、因为 webpack 是在 nodejs 环境运行，所以其配置文件通常使用 CommonJS 规范。
3.2.4、因为 ES Modules 通常需要配合打包工具进行使用，所以 webpack 可以算得上它的加载器。</p>
<h2>4. ES Module 基本使用知识点</h2>
<p><strong>4.1、ES Modules虽然是ES6才出现的规范，但是未来浏览器原生支持</strong></p>
<p><strong>4.2、ES Modules支持在script标签上直接定义使用：</strong>
4.2.1. ESM 自动采用严格模式，忽略 ‘use strict’
4.2.2. 每个 ES Module 都是运行在单独的私有作用域中
4.2.3. ESM 是通过 CORS 的方式请求外部 JS 模块的
4.2.4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>ES Module - 模块的特性<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;this is es module&#x27;</span>)
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 1. ESM 自动采用严格模式，忽略 &#x27;use strict&#x27; --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">100</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo)
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的 --&gt;</span>
  <span class="hljs-comment">&lt;!-- &lt;script type=&quot;module&quot; src=&quot;https://unpkg.com/jquery@3.4.1/dist/jquery.min.js&quot;&gt;&lt;/script&gt; --&gt;</span>

  <span class="hljs-comment">&lt;!-- 4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;demo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>需要显示的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><strong>4.3、ES Modules 的 export和 import：</strong></p>
<ul>
<li>导出：</li>
<li>export { } 后面不是一个对象，而是固定用法 { XXX }，import { sss } from module也是固定用法，不是解构语法；export default { } 后面才可以跟一个对象、字符串等都行。</li>
<li>export 导出的是一个引用关系，而且是只读的！不是深拷贝的对象。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;foo module&#x27;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">hello</span> () {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {}

<span class="hljs-keyword">export</span> { 
  name <span class="hljs-keyword">as</span> foo, 
  hello, 
  <span class="hljs-title class_">Person</span> 
}
</code></pre>
<ul>
<li>导入（导入路径必须完整）：</li>
<li>文件名称必须完整，不能省略.js、/index.js；</li>
<li>相对路径也必须完整，不能省略./；</li>
<li>可以绝对路径或者完整的url</li>
</ul>
<blockquote>
<p>import不支持动态导入，需要使用import().then()</p>
</blockquote>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { foo, hello, <span class="hljs-title class_">Person</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, hello, <span class="hljs-title class_">Person</span>)

<span class="hljs-comment">// 只加载模块不提取模块变量，可以简写：import &#x27;./module.js&#x27;</span>
<span class="hljs-keyword">import</span> {} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>

<span class="hljs-comment">// 导入模块内的全部变量</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> mod <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mod)

<span class="hljs-comment">// 动态导入</span>
<span class="hljs-title function_">import</span>(<span class="hljs-string">&#x27;./module.js&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>)
})
</code></pre>
<p><strong>4.4、ES Modules 的 export default</strong></p>
<ul>
<li>export default 后面可以跟对象、字符串等类型</li>
<li>export 过后可以继续添加 export default</li>
<li>import 的第一个位置默认对应export default 导出的值</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// module.js</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;jack&#x27;</span>
<span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>

<span class="hljs-keyword">export</span> { name, age }
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;module action&#x27;</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;default export&#x27;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// import.js</span>
<span class="hljs-comment">// import { name, age, default as title } from &#x27;./module.js&#x27;</span>
<span class="hljs-comment">// abc 为 export default 导出值的重命名，abc 后面的 { } 不是对象解构，而是固定用法</span>
<span class="hljs-comment">// import abc from &#x27;./module.js&#x27;</span>
<span class="hljs-keyword">import</span> abc, { name, age } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.js&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age, abc)
</code></pre>
<p><strong>4.5、ES Modules 的浏览器兼容</strong>
IE基本不兼容ES Modules</p>
<p>插件 browser-es-module-loader 用于兼容ES Modules（开发阶段可用，不建议生产环境使用）
1、在html中直接使用，参考：<a href="https://www.npmjs.com/package/browser-es-module-loader">npm官方地址</a></p>
<pre><code class="language-js"><span class="hljs-comment">// 该方法需要动态的去解析脚本执行ESM，性能差！只能在开发阶段使用。</span>
<span class="hljs-comment">// script加上nomodule 属性，避免在支持ESM的浏览器上执行两次</span>
<span class="hljs-comment">// babel-browser-build.js为babel的运行环境（浏览器端）</span>
&lt;script nomodule src=<span class="hljs-string">&quot;dist/babel-browser-build.js&quot;</span>&gt;&lt;/script&gt;
<span class="hljs-comment">// ES Modules把代码读出来交给babel转换</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;dist/browser-es-module-loader.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
 
&lt;!-- script type=<span class="hljs-variable language_">module</span> loading --&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;path/to/module.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>

...
</code></pre>
<p>2、npm中使用，估计还是作为依赖资源动态解析ESM（不建议使用）</p>
<pre><code>npm install browser-es-module-loader --save-dev
</code></pre>
<p><strong>4.6、ES Modules 的NodeJS支持情况（8.5+版本）</strong>
NodeJS 8.5以上的版本支持ES Modules，但是还是实验版本；</p>
<pre><code class="language-js"><span class="hljs-comment">// 第一，将文件的扩展名由 .js 改为 .mjs；（nodejs 12.10版本以上不需要修改文件名了）</span>
<span class="hljs-comment">// 第二，启动时需要额外添加 `--experimental-modules` 参数；</span>

<span class="hljs-keyword">import</span> { foo, bar } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module.mjs&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo, bar)

<span class="hljs-comment">// 此时我们也可以通过 esm 加载内置模块了</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>
fs.<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;./foo.txt&#x27;</span>, <span class="hljs-string">&#x27;es module working&#x27;</span>)

<span class="hljs-comment">// 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员方式</span>
<span class="hljs-keyword">import</span> { writeFileSync } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>
<span class="hljs-title function_">writeFileSync</span>(<span class="hljs-string">&#x27;./bar.txt&#x27;</span>, <span class="hljs-string">&#x27;es module working&#x27;</span>)

<span class="hljs-comment">// 对于第三方的 NPM 模块也可以通过 esm 加载</span>
<span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>
_.<span class="hljs-title function_">camelCase</span>(<span class="hljs-string">&#x27;ES Module&#x27;</span>)

<span class="hljs-comment">// 不支持，因为第三方模块都是导出默认成员</span>
<span class="hljs-comment">// import { camelCase } from &#x27;lodash&#x27;</span>
<span class="hljs-comment">// console.log(camelCase(&#x27;ES Module&#x27;))</span>

</code></pre>
<p><strong>4.7、ES Modules 和CommonJS相互使用（在NodeJS环境中）</strong></p>
<ul>
<li>ESM 中可用导入CommonJS</li>
<li>CommonJS中不能导入ESM</li>
<li>CommonJS始终只会导出一个默认成员</li>
<li>import不是解构导出对象，只能：import mod from ‘./commonjs.js’</li>
</ul>
<p><strong>4.8、ES Modules 和CommonJS的差异（在NodeJS环境中）</strong></p>
<pre><code class="language-js"><span class="hljs-comment">// nodejs、CommonJS，文件名为：mjs</span>
<span class="hljs-comment">// 加载模块函数</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">require</span>)

<span class="hljs-comment">// 模块对象</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>)

<span class="hljs-comment">// 导出对象别名</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">exports</span>)

<span class="hljs-comment">// 当前文件的绝对路径</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__filename)

<span class="hljs-comment">// 当前文件所在目录</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__dirname)

</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// nodejs、ES Modules，文件名为：mjs</span>
<span class="hljs-comment">// require, module, exports 自然是通过 import 和 export 代替</span>

<span class="hljs-comment">// __filename 和 __dirname 通过 import 对象的 meta 属性获取</span>
<span class="hljs-comment">// const currentUrl = import.meta.url</span>
<span class="hljs-comment">// console.log(currentUrl)</span>

<span class="hljs-comment">// 通过 url 模块的 fileURLToPath 方法转换为路径</span>
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;url&#x27;</span>
<span class="hljs-keyword">import</span> { dirname } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>
<span class="hljs-keyword">const</span> __filename = <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>)
<span class="hljs-keyword">const</span> __dirname = <span class="hljs-title function_">dirname</span>(__filename)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__filename)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(__dirname)
</code></pre>
<h2>5. Webpack 基于所有资源去做模块化</h2>
<p>完整的讲解参考后续文章：待续；</p>
<p>5.1、支持新特性语言版本的编译
5.2、针对javascript模块化打包
5.3、针对所有资源，例如样式、图片、字体等进行模块化</p>
<p>对于1、2两点，grunt、gulp等脚手架可以很好的解决，但是无法解决第3点。</p>
<h2>6、Rollup：专门针对ES Modules进行打包的轻量化工具</h2>
<ul>
<li>webpack 大而全 =&gt; 适合做大型应用程序</li>
<li>rollup 小而美 =&gt; 适合做类库</li>
</ul>
<h2>7、Parcel：零配置专用打包器，简单易用</h2>
<h2>8、参考资料：</h2>
<p><a href="https://es6.ruanyifeng.com/#docs/module-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82">ES6-模块与-CommonJS-模块的差异</a></p>
<p><a href="https://kaiwu.lagou.com/">特别鸣谢：拉勾教育前端高薪训练营</a></p>
</div></div></div></div></main></section></section></content><footer class="footer"><div class="el-row el-row"><div class="el-col el-col-10"><div>
          © 2021 Tony Young  
          <a href="https://github.com/ymcdhr" target="_blank">Profile</a>  
          <a href="https://segmentfault.com/u/tonyyoung" target="_blank">Blog</a></div></div><div class="el-col el-col-4"><div style="text-align:center;font-size:12px;"><a href="" target="_blank">托泥羊技术有限公司</a>  
        </div></div><div class="el-col el-col-10"><div style="float:right;"><a href="https://developer.github.com" target="_blank">GitHub-API</a>  
        <a href="https://cn.vuejs.org/" target="_blank">Vue.js</a>  
        <a href="http://element.eleme.io/" target="_blank">Element</a></div></div></div></footer><!----></div>
    <script>window.__INITIAL_STATE__={"data":{"data":{"id":"11","title":"前端工程化4：如何去做js模块化开发？ES Modules\u002FCommonJS有什么区别？","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"\u002Fuploads\u002Flogo_521b3eebb2.jpg"}},"content":"\n## 1. 如何去做js模块化开发 =\u003E 模块化标准 + 加载器\n1.1、我们说讨论的仅限于javascript代码的模块化，如果要涉及到所有文件的模块化请使用webpack。\n1.2、那么js的模块化可以用一句话概括：模块化标准 + 加载器；本文主要介绍模块化标准。\n \n## 2. 几种模块化标准对比：\n\n#### CommonJS\n1、以同步的模式加载模块：通常在Nodejs环境使用，不适合浏览器\n```\n1. 因为服务器读本地磁盘文件会比较快，所以nodejs的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；\n2. 如果在浏览器端代码执行时去同步require很多模块，也会影响页面执行效率。\n```\n2、一个文件就是一个模块，且每个模块都有单独的作用域；因为模块输出的是一个值的浅拷贝。\n3、require(模块)加载的是一个对象，该对象是运行时生成；\n4、导入导出\n```js\n\u002F\u002F 导出\nmodule.exports = {\n    name: 'wangyi',\n    age: 18\n}\n\n\u002F\u002F 导入\nconst { name, age } = require('.\u002Fmodule.js')\n```\n\n#### ES Modules\n1、以异步的模式加载模块：支持Nodejs环境使用，也适合浏览器（ES6以上才支持的规范，存在兼容性问题，最好配合 webpack 进行加载）；\n2、ES Modules的导入导出是固定用法，输出的是值的只读引用（原始值变了，取值跟着变）；\n3、ES Modules的导入导出不是对象而是对外接口，该接口在代码编译时就完成，执行效率更高\n4、导入导出\n```js\n\u002F\u002F 注意：此处是固定用法，export 后面不是对象；export default 后面才是对象\n\n\u002F\u002F 导出1\nexport { name, age }\n\u002F\u002F 导入1\nimport { name, age } from '.\u002Fmodule.js'\n\n\u002F\u002F 导出2\nexport default { name, age }\n\u002F\u002F 导入2\nimport module from '.\u002Fmodule.js'\nconst { name, age } = module\n```\n\n#### AMD + require.js\n1、以异步的方式加载模块，可以指定回调函数；\n2、AMD规范配合require.js库作为加载器使用；\n3、目前绝大多数第三方库都支持AMD\n4、使用起来比较复杂\n5、模块js文件请求频繁，因为每个模块都会创建一个script标签去请求文件\n6、导入导出\n```js\ndefine('module1', ['jquery', '.\u002Fmodule2'], function($, module2){\n  return {\n    \u002F\u002F 可以在里面使用依赖的 $、module2 模块\n  }\n})\n```\n\n#### CMD + sea.js\nCMD规范配合sea.js库作为加载器使用，实现了模块化开发（淘宝）；后来sea.js被require.js兼容了，便不再使用。\n\n\n\n\n\n\n## 3. 模块化标准使用最佳实践\n#### 3.1、Nodejs环境 =\u003E CommonJS\n3.1.1、因为服务器读本地磁盘文件会比较快，所以 nodejs 的执行机制是在启动的时候加载所有模块，不需要在执行过程中才加载模块；\n3.1.2、如果在浏览器端代码执行时去同步 require 很多模块，也会影响页面执行效率。\n3.1.3、module 对象是在 Nodejs环境定义的，配合 require 函数使用；如果说谁是 CommonJS 的加载器，那就是 Nodejs环境。\n\n#### 3.2、浏览器端 =\u003E ES Modules + Webpack\n3.2.1、因为浏览器端会有很多的异步加载且当前的ES6开发比较简单，所以浏览器端适合使用ES Modules。\n3.2.2、ES Modules 通常经过 webpack + babel 进行转换；将其转换成立即执行函数的方式，以此来模仿块级作用域；（webpack 也支持在源码中使用 CommonJS 和 ESM 互相导入导出，但一般不用）\n3.2.3、因为 webpack 是在 nodejs 环境运行，所以其配置文件通常使用 CommonJS 规范。\n3.2.4、因为 ES Modules 通常需要配合打包工具进行使用，所以 webpack 可以算得上它的加载器。\n\n\n## 4. ES Module 基本使用知识点\n\n **4.1、ES Modules虽然是ES6才出现的规范，但是未来浏览器原生支持**\n \n **4.2、ES Modules支持在script标签上直接定义使用：** \n4.2.1. ESM 自动采用严格模式，忽略 'use strict'\n4.2.2. 每个 ES Module 都是运行在单独的私有作用域中\n4.2.3. ESM 是通过 CORS 的方式请求外部 JS 模块的\n4.2.4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果\n```html\n\u003C!DOCTYPE html\u003E\n\u003Chtml lang=\"en\"\u003E\n\u003Chead\u003E\n  \u003Cmeta charset=\"UTF-8\"\u003E\n  \u003Cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003E\n  \u003Cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003E\n  \u003Ctitle\u003EES Module - 模块的特性\u003C\u002Ftitle\u003E\n\u003C\u002Fhead\u003E\n\u003Cbody\u003E\n  \u003C!-- 通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了 --\u003E\n  \u003Cscript type=\"module\"\u003E\n    console.log('this is es module')\n  \u003C\u002Fscript\u003E\n\n  \u003C!-- 1. ESM 自动采用严格模式，忽略 'use strict' --\u003E\n  \u003Cscript type=\"module\"\u003E\n    console.log(this)\n  \u003C\u002Fscript\u003E\n\n  \u003C!-- 2. 每个 ES Module 都是运行在单独的私有作用域中 --\u003E\n  \u003Cscript type=\"module\"\u003E\n    var foo = 100\n    console.log(foo)\n  \u003C\u002Fscript\u003E\n  \u003Cscript type=\"module\"\u003E\n    console.log(foo)\n  \u003C\u002Fscript\u003E\n\n  \u003C!-- 3. ESM 是通过 CORS 的方式请求外部 JS 模块的 --\u003E\n  \u003C!-- \u003Cscript type=\"module\" src=\"https:\u002F\u002Funpkg.com\u002Fjquery@3.4.1\u002Fdist\u002Fjquery.min.js\"\u003E\u003C\u002Fscript\u003E --\u003E\n\n  \u003C!-- 4. ESM 的 script 标签会延迟执行脚本，和defer一样的效果 --\u003E\n  \u003Cscript type=\"module\" src=\"demo.js\"\u003E\u003C\u002Fscript\u003E\n  \u003Cp\u003E需要显示的内容\u003C\u002Fp\u003E\n\u003C\u002Fbody\u003E\n\u003C\u002Fhtml\u003E\n```\n\n **4.3、ES Modules 的 export和 import：** \n- 导出：\n - export { } 后面不是一个对象，而是固定用法 { XXX }，import { sss } from module也是固定用法，不是解构语法；export default { } 后面才可以跟一个对象、字符串等都行。\n - export 导出的是一个引用关系，而且是只读的！不是深拷贝的对象。\n\n```js\nvar name = 'foo module'\n\nfunction hello () {\n  console.log('hello')\n}\n\nclass Person {}\n\nexport { \n  name as foo, \n  hello, \n  Person \n}\n```\n\n- 导入（导入路径必须完整）：\n - 文件名称必须完整，不能省略.js、\u002Findex.js；\n - 相对路径也必须完整，不能省略.\u002F；\n - 可以绝对路径或者完整的url\n\n\u003E import不支持动态导入，需要使用import().then()\n```js\nimport { foo, hello, Person } from '.\u002Fmodule.js'\nconsole.log(name, hello, Person)\n\n\u002F\u002F 只加载模块不提取模块变量，可以简写：import '.\u002Fmodule.js'\nimport {} from '.\u002Fmodule.js'\nimport '.\u002Fmodule.js'\n\n\u002F\u002F 导入模块内的全部变量\nimport * as mod from '.\u002Fmodule.js'\nconsole.log(mod)\n\n\u002F\u002F 动态导入\nimport('.\u002Fmodule.js').then(function (module) {\n  console.log(module)\n})\n```\n\n\n\n **4.4、ES Modules 的 export default**\n- export default 后面可以跟对象、字符串等类型\n- export 过后可以继续添加 export default \n- import 的第一个位置默认对应export default 导出的值\n\n```js\n\u002F\u002F module.js\nvar name = 'jack'\nvar age = 18\n\nexport { name, age }\nconsole.log('module action')\nexport default 'default export'\n```\n\n```js\n\u002F\u002F import.js\n\u002F\u002F import { name, age, default as title } from '.\u002Fmodule.js'\n\u002F\u002F abc 为 export default 导出值的重命名，abc 后面的 { } 不是对象解构，而是固定用法\n\u002F\u002F import abc from '.\u002Fmodule.js'\nimport abc, { name, age } from '.\u002Fmodule.js'\nconsole.log(name, age, abc)\n```\n\n **4.5、ES Modules 的浏览器兼容**\nIE基本不兼容ES Modules\n\n插件 browser-es-module-loader 用于兼容ES Modules（开发阶段可用，不建议生产环境使用）\n1、在html中直接使用，参考：[npm官方地址](https:\u002F\u002Fwww.npmjs.com\u002Fpackage\u002Fbrowser-es-module-loader)\n\n```js\n\u002F\u002F 该方法需要动态的去解析脚本执行ESM，性能差！只能在开发阶段使用。\n\u002F\u002F script加上nomodule 属性，避免在支持ESM的浏览器上执行两次\n\u002F\u002F babel-browser-build.js为babel的运行环境（浏览器端）\n\u003Cscript nomodule src=\"dist\u002Fbabel-browser-build.js\"\u003E\u003C\u002Fscript\u003E\n\u002F\u002F ES Modules把代码读出来交给babel转换\n\u003Cscript nomodule src=\"dist\u002Fbrowser-es-module-loader.js\"\u003E\u003C\u002Fscript\u003E\n \n\u003C!-- script type=module loading --\u003E\n\u003Cscript nomodule  type=\"module\" src=\"path\u002Fto\u002Fmodule.js\"\u003E\u003C\u002Fscript\u003E\n\n...\n```\n\n2、npm中使用，估计还是作为依赖资源动态解析ESM（不建议使用）\n```\nnpm install browser-es-module-loader --save-dev\n```\n\n\n\n **4.6、ES Modules 的NodeJS支持情况（8.5+版本）**\nNodeJS 8.5以上的版本支持ES Modules，但是还是实验版本；\n```js\n\u002F\u002F 第一，将文件的扩展名由 .js 改为 .mjs；（nodejs 12.10版本以上不需要修改文件名了）\n\u002F\u002F 第二，启动时需要额外添加 `--experimental-modules` 参数；\n\nimport { foo, bar } from '.\u002Fmodule.mjs'\n\nconsole.log(foo, bar)\n\n\u002F\u002F 此时我们也可以通过 esm 加载内置模块了\nimport fs from 'fs'\nfs.writeFileSync('.\u002Ffoo.txt', 'es module working')\n\n\u002F\u002F 也可以直接提取模块内的成员，内置模块兼容了 ESM 的提取成员方式\nimport { writeFileSync } from 'fs'\nwriteFileSync('.\u002Fbar.txt', 'es module working')\n\n\u002F\u002F 对于第三方的 NPM 模块也可以通过 esm 加载\nimport _ from 'lodash'\n_.camelCase('ES Module')\n\n\u002F\u002F 不支持，因为第三方模块都是导出默认成员\n\u002F\u002F import { camelCase } from 'lodash'\n\u002F\u002F console.log(camelCase('ES Module'))\n\n```\n\n\n\n\n\n **4.7、ES Modules 和CommonJS相互使用（在NodeJS环境中）**\n\n- ESM 中可用导入CommonJS\n- CommonJS中不能导入ESM\n- CommonJS始终只会导出一个默认成员\n- import不是解构导出对象，只能：import mod from '.\u002Fcommonjs.js'\n\n\n\n **4.8、ES Modules 和CommonJS的差异（在NodeJS环境中）**\n```js\n\u002F\u002F nodejs、CommonJS，文件名为：mjs\n\u002F\u002F 加载模块函数\nconsole.log(require)\n\n\u002F\u002F 模块对象\nconsole.log(module)\n\n\u002F\u002F 导出对象别名\nconsole.log(exports)\n\n\u002F\u002F 当前文件的绝对路径\nconsole.log(__filename)\n\n\u002F\u002F 当前文件所在目录\nconsole.log(__dirname)\n\n```\n\n```js\n\u002F\u002F nodejs、ES Modules，文件名为：mjs\n\u002F\u002F require, module, exports 自然是通过 import 和 export 代替\n\n\u002F\u002F __filename 和 __dirname 通过 import 对象的 meta 属性获取\n\u002F\u002F const currentUrl = import.meta.url\n\u002F\u002F console.log(currentUrl)\n\n\u002F\u002F 通过 url 模块的 fileURLToPath 方法转换为路径\nimport { fileURLToPath } from 'url'\nimport { dirname } from 'path'\nconst __filename = fileURLToPath(import.meta.url)\nconst __dirname = dirname(__filename)\nconsole.log(__filename)\nconsole.log(__dirname)\n```\n\n## 5. Webpack 基于所有资源去做模块化\n完整的讲解参考后续文章：待续；\n\n5.1、支持新特性语言版本的编译\n5.2、针对javascript模块化打包\n5.3、针对所有资源，例如样式、图片、字体等进行模块化\n\n对于1、2两点，grunt、gulp等脚手架可以很好的解决，但是无法解决第3点。\n\n## 6、Rollup：专门针对ES Modules进行打包的轻量化工具 \n- webpack 大而全 =\u003E 适合做大型应用程序\n- rollup 小而美 =\u003E 适合做类库\n\n\n## 7、Parcel：零配置专用打包器，简单易用\n\n\n## 8、参考资料：\n[ES6-模块与-CommonJS-模块的差异](https:\u002F\u002Fes6.ruanyifeng.com\u002F#docs\u002Fmodule-loader#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%B7%AE%E5%BC%82)\n\n\n[特别鸣谢：拉勾教育前端高薪训练营](https:\u002F\u002Fkaiwu.lagou.com\u002F)","published_at":"2021-07-11T15:03:27.212Z","updated_at":"2021-07-12T07:15:26.316Z"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.aa04e74c.js" defer></script><script src="/assets/js/page--src-templates-blog-vue.a3da5a2e.js" defer></script>
  </body>
</html>
