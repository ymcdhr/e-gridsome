<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>首页 - Grdsome 博客</title><meta name="gridsome:hash" content="87002c5fa157b6e786d19711f6bffff4b0d9c799"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/8.styles.8d7e1c32.css" as="style"><link rel="preload" href="/assets/js/app.aa04e74c.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-blog-vue.a3da5a2e.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.0ddd1ab5.js"><link rel="prefetch" href="/assets/js/page--src-templates-blog-list-vue.8a24ccb4.js"><link rel="prefetch" href="/assets/js/page--src-templates-new-vue.8b4559ca.js"><link rel="prefetch" href="/assets/js/page--src-templates-project-list-vue.ba063837.js"><link rel="prefetch" href="/assets/js/page--src-templates-project-vue.7a542983.js"><link rel="prefetch" href="/assets/js/page--src-templates-social-vue.3a209dab.js"><link rel="stylesheet" href="/assets/css/8.styles.8d7e1c32.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div id="app" data-server-rendered="true" class="layout"><header class="header" style="background-image:;"><div class="cover"></div><div class="user"><div class="el-image"><div class="el-image__placeholder"></div><!----></div><div class="name"></div><div class="description"></div></div></header><content class="content"><section class="el-container box is-vertical"><header class="el-header header" style="height:60px;"><div class="el-row"><div class="el-col el-col-24"><a><button type="button" class="el-button el-button--default"><!----><i class="el-icon-edit"></i><span>修改文章</span></button></a></div></div></header><section class="el-container cnt"><aside class="el-aside aside" style="width:200px;"><ul role="menubar" class="menu el-menu" style="background-color:;"><a href="/new?username=undefined"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-menu"></i><span>最新动态</span></li></a><a href="/blog-list"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-notebook-2"></i><span>博客列表</span></li></a><a href="/social"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-bangzhu"></i><span>关注账号</span></li></a><a href="/project-list"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-orange"></i><span>我的项目</span></li></a></ul></aside><main class="el-main main"><div class="article"><div class="markdown-title"><div class="title">
            前端工程化2：如何理解前端工程化？
        </div><div class="el-divider el-divider--horizontal"><!----></div><div class="time"><div class="updated">更新时间：2021/7/12</div><div class="published">发布时间：2021/7/11</div></div></div><div class="markdown-cnt"><!----><div class="cnt"><!----><div class="markdown-here-wrapper"><h2>1、前端工程化解决的问题</h2>
<h4>1.1 为什么需要前端工程化？</h4>
<p>前端技术发展更新快，一些大型前端项目需要更系统化、更规范化的去组织开发工作；以此来提高对项目的开发效率，减少维护成本。</p>
<p>例如：</p>
<p>我们做一个电商网站（类似淘宝），它有各种商品页、活动页、详情页、列表页等。它有几个特点：</p>
<ol>
<li>每个页面功能高度类似，但还是有一些差别；<br></li>
<li>它们之间有很多公共依赖；也有一些公共的接口；<br></li>
<li>每个页面都作为一个独立的项目由不同的团队或者个人开发。<br></li>
</ol>
<p>这时候为了避免混乱和提升开发效率，就需要有：</p>
<ol>
<li><strong>统一的开发规范</strong>  =&gt; 提高代码质量，减少维护成本</li>
<li><strong>统一的文件组织结构</strong>  =&gt; 清新美观的目录结构，便于定位问题</li>
<li><strong>统一的的模块依赖</strong>  =&gt; 相同依赖直接复用，不需要每次新建项目都copy</li>
<li><strong>统一的工具配置</strong>  =&gt; 相同配置直接复用，发布、打包、上传等工作自动化</li>
<li><strong>统一的基础代码</strong>  =&gt; 相同代码直接复用，不需要每次新建项目都copy</li>
</ol>
<h4>1.2 前端工程化解决的问题：</h4>
<p>传统的前端开发方式存在一些问题，为了提升整体开发效率并降低代码维护成本；我们需要实现前端开发工程化，它能解决如下问题：</p>
<p><strong>1、 传统语言和语法在各端的兼容性不好；</strong></p>
<blockquote>
<p>例如，现在的项目通常都是用es6+或者ts去开发；而一些政企项目中客户（特别是国企的客户）还在用一些老电脑，使用的IE8、IE9、IE10等老的浏览器版本不兼容es6+的执行，需要转换为es5甚至es3到浏览器去执行；</p>
</blockquote>
<p><strong>2、 一些项目无法使用模块化/组件化；</strong></p>
<blockquote>
<p>例如，以前做的一个数据可视化项目中有大量图表组件；这些图表组件的代码量和数量很多，全部一次加载浏览器速度很慢。所以需要考虑图表组件的按需加载，那就需要webpack这样的工具来配合做图表的模块化和组件化。</p>
</blockquote>
<p><strong>3、 重复机械式的工作/重复造轮子；</strong></p>
<blockquote>
<p>工程化时，我们可以将重复代码提取成公用的模块或者库供所有人使用，避免重复造轮子；</p>
</blockquote>
<p><strong>4、 没有代码风格统一、质量保证</strong></p>
<blockquote>
<p>在开发中如果没有统一的代码书写规范，那么会造成项目开发的混乱，会在项目中遗留很多隐性的BUG，也会导致后期项目维护成本升高。所以我们通常使用eslint、csslint等工具来检查代码书写规范。</p>
</blockquote>
<p><strong>5、 前后端分离开发过程中，依赖后端服务支持导致效率低下</strong></p>
<blockquote>
<p>现在的项目开发中，为了提升效率和项目解耦通常采用了前后端分离的方式；但是前端开发和后端开发是同时进行，大概率情况下前端所需后端接口不能及时提供；所以我们需要使用mock等工具自己去模拟接口。</p>
</blockquote>
<h2>2、前端工程化流程</h2>
<p>创建项目 =&gt; 编码 =&gt; 预览/测试 =&gt; 提交 =&gt; 部署</p>
<p><img src="/img/bVcSWdu" alt=""></p>
<h4>2.1 创建项目</h4>
<p>在项目开发初期，我们可以实用工具自动创建一些脚手架、模板、通用等文件；还能够创建项目结构、创建特定类型文件，例如：</p>
<ul>
<li>创建vue项目：vue-cli</li>
<li>创建react项目：create-react-app</li>
<li>自定义nodejs cli应用：根据自己需求实现的工具，可以自定义创建项目、生成项目描述文件等。</li>
</ul>
<h4>2.2 编码</h4>
<p>在正式堆代码的时候，可能会有多人协同开发的场景；这时候需要我们制定编码规范来约束开发人员的编码风格，并使用工具来代替人为约定。除此之外，还可以使用一些自动化工具来替我们自动构建、自动编译打包。</p>
<ul>
<li>格式化代码：prettier</li>
<li>校验代码风格：eslint、stylelint</li>
<li>编译/构建/打包/模块化：grunt、gulp、fis3、webpack、babel</li>
</ul>
<h4>2.3 预览/测试</h4>
<p>在开发本地调试的时候，我们可以使用一些工具来模拟服务器场景并实现热更新、热加载；即代码修改后自动编译构建，浏览器根据变化自动刷新同时还要方便我们查看源码。</p>
<ul>
<li>本地服务：WebServer / Mock</li>
<li>热加载/热更新：Live Reloading / HMR</li>
<li>源码映射：Source Map</li>
</ul>
<h4>2.4 提交</h4>
<ul>
<li>Git Hooks：可在提交前进行代码质量和风格的检查</li>
<li>Lint-staged</li>
<li>持续集成</li>
</ul>
<h4>2.5 部署</h4>
<ul>
<li>自动化部署：CI/CD</li>
<li>自动化集成：Jenkins 可以调用执行脚本，集成自动化构建、打包、部署等</li>
</ul>
<h2>3、常用的通用脚手架工具</h2>
<p><strong>vue-cli</strong> —— 创建vue项目的工具
<strong>create-react-app</strong> —— 创建react项目的工具
<strong>Yeoman</strong> —— 用于创建自定义脚手架的工具
<strong>Plop</strong> —— 用于项目中，重复创建相同类型的项目文件（例如vue中某个组件的js、css文件）</p>
<h2>4、常用的自动化构建工具</h2>
<p>Grunt</p>
<ul>
<li>插件完善</li>
<li>构建速度慢（每一步都有临时文件读写，步骤越多）</li>
</ul>
<p>Gulp</p>
<ul>
<li>插件完善</li>
<li>构建速度更快（没有临时文件，基于内存实现）</li>
<li>默认支持多个任务同时执行</li>
<li>使用方式更直观易懂</li>
</ul>
<p>Fis</p>
<ul>
<li>百度开源项目</li>
<li>大而全的构建工具，集成度高一些</li>
</ul>
<p>Webpack</p>
<ul>
<li>准确说是模块打包工具，也可以完成自动化构建的功能</li>
</ul>
<h2>5、开发阶段实践方案</h2>
<p>例如：我们要开发一个大型的vue项目，最基本的前端开发工程化需要如下工作：</p>
<p>####5.1. 创建项目</p>
<ol>
<li>自定义一个nodejs cli应用并发布到npm上（方法见后续文章）</li>
<li>使用nodejs cli应用创建一个项目，会生成源码目录结构、模板文件、公用文件、构建工具配置等，例如：package.json、webpack.config.js、eslint.lrc等</li>
<li>使用nodejs cli应用自动调用npm install等工作（可选）</li>
</ol>
<p>####5.2 编码</p>
<ol>
<li>使用webpack进行构建，通过插件babel转换es6+、sass/less、vue模板代码等</li>
<li>使用webpack配合ES Modules/CommJS规范进行模块化开发</li>
<li>使用eslint、stylelint进行代码规范检查</li>
<li>使用prettier进行代码格式化</li>
</ol>
<p>####5.3 预览/测试</p>
<ol>
<li>使用browser-sync、webpack-dev-server作为本地web服务，并进行热更新热加载</li>
<li>使用webpack配置的source map来调试源码</li>
<li>使用webpack配置的proxy、Nginx代理来解决跨域问题</li>
<li>使用mock模拟web服务器的http接口</li>
</ol>
<p>####5.4 提交</p>
<ol>
<li>使用git + github做代码管理（其它gitee或者自己搭的仓库也可）</li>
<li>结合npm scripts、git hooks、lint-staged在提交代码前进行代码规范检查</li>
</ol>
<p>####5.5 部署</p>
<ol>
<li>使用Jinkens调用命令行进行webpack打包，然后执行一系列后续操作</li>
<li>然后配合其它的工具可自动发布到我们需要的系统上去（根据公司需求可自定义）</li>
</ol>
<p><a href="https://kaiwu.lagou.com/">特别鸣谢：拉勾教育前端高薪训练营</a></p>
</div></div></div></div></main></section></section></content><footer class="footer"><div class="el-row el-row"><div class="el-col el-col-10"><div>
          © 2021 Tony Young  
          <a href="https://github.com/ymcdhr" target="_blank">Profile</a>  
          <a href="https://segmentfault.com/u/tonyyoung" target="_blank">Blog</a></div></div><div class="el-col el-col-4"><div style="text-align:center;font-size:12px;"><a href="" target="_blank">托泥羊技术有限公司</a>  
        </div></div><div class="el-col el-col-10"><div style="float:right;"><a href="https://developer.github.com" target="_blank">GitHub-API</a>  
        <a href="https://cn.vuejs.org/" target="_blank">Vue.js</a>  
        <a href="http://element.eleme.io/" target="_blank">Element</a></div></div></div></footer><!----></div>
    <script>window.__INITIAL_STATE__={"data":{"data":{"id":"9","title":"前端工程化2：如何理解前端工程化？","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"\u002Fuploads\u002Flogo_521b3eebb2.jpg"}},"content":"## 1、前端工程化解决的问题\n\n#### 1.1 为什么需要前端工程化？\n前端技术发展更新快，一些大型前端项目需要更系统化、更规范化的去组织开发工作；以此来提高对项目的开发效率，减少维护成本。\n\n例如：\n\n我们做一个电商网站（类似淘宝），它有各种商品页、活动页、详情页、列表页等。它有几个特点：\n1. 每个页面功能高度类似，但还是有一些差别；\u003Cbr\u003E\n2. 它们之间有很多公共依赖；也有一些公共的接口；\u003Cbr\u003E\n3. 每个页面都作为一个独立的项目由不同的团队或者个人开发。\u003Cbr\u003E\n\n这时候为了避免混乱和提升开发效率，就需要有：\n\n1. **统一的开发规范**  =\u003E 提高代码质量，减少维护成本\n2. **统一的文件组织结构**  =\u003E 清新美观的目录结构，便于定位问题\n3. **统一的的模块依赖**  =\u003E 相同依赖直接复用，不需要每次新建项目都copy\n4. **统一的工具配置**  =\u003E 相同配置直接复用，发布、打包、上传等工作自动化\n5. **统一的基础代码**  =\u003E 相同代码直接复用，不需要每次新建项目都copy\n\n\n#### 1.2 前端工程化解决的问题：\n传统的前端开发方式存在一些问题，为了提升整体开发效率并降低代码维护成本；我们需要实现前端开发工程化，它能解决如下问题：\n\n**1、 传统语言和语法在各端的兼容性不好；**\n\u003E 例如，现在的项目通常都是用es6+或者ts去开发；而一些政企项目中客户（特别是国企的客户）还在用一些老电脑，使用的IE8、IE9、IE10等老的浏览器版本不兼容es6+的执行，需要转换为es5甚至es3到浏览器去执行；\n\n**2、 一些项目无法使用模块化\u002F组件化；**\n\u003E 例如，以前做的一个数据可视化项目中有大量图表组件；这些图表组件的代码量和数量很多，全部一次加载浏览器速度很慢。所以需要考虑图表组件的按需加载，那就需要webpack这样的工具来配合做图表的模块化和组件化。\n\n**3、 重复机械式的工作\u002F重复造轮子；**\n\u003E 工程化时，我们可以将重复代码提取成公用的模块或者库供所有人使用，避免重复造轮子；\n\n**4、 没有代码风格统一、质量保证**\n\u003E 在开发中如果没有统一的代码书写规范，那么会造成项目开发的混乱，会在项目中遗留很多隐性的BUG，也会导致后期项目维护成本升高。所以我们通常使用eslint、csslint等工具来检查代码书写规范。\n\n**5、 前后端分离开发过程中，依赖后端服务支持导致效率低下**\n\u003E 现在的项目开发中，为了提升效率和项目解耦通常采用了前后端分离的方式；但是前端开发和后端开发是同时进行，大概率情况下前端所需后端接口不能及时提供；所以我们需要使用mock等工具自己去模拟接口。\n\n\n\n\n## 2、前端工程化流程\n\n创建项目 =\u003E 编码 =\u003E 预览\u002F测试 =\u003E 提交 =\u003E 部署\n\n![](\u002Fimg\u002FbVcSWdu)\n\n#### 2.1 创建项目 \n在项目开发初期，我们可以实用工具自动创建一些脚手架、模板、通用等文件；还能够创建项目结构、创建特定类型文件，例如：\n- 创建vue项目：vue-cli\n- 创建react项目：create-react-app\n- 自定义nodejs cli应用：根据自己需求实现的工具，可以自定义创建项目、生成项目描述文件等。\n\n\n#### 2.2 编码\n在正式堆代码的时候，可能会有多人协同开发的场景；这时候需要我们制定编码规范来约束开发人员的编码风格，并使用工具来代替人为约定。除此之外，还可以使用一些自动化工具来替我们自动构建、自动编译打包。\n- 格式化代码：prettier\n- 校验代码风格：eslint、stylelint\n- 编译\u002F构建\u002F打包\u002F模块化：grunt、gulp、fis3、webpack、babel\n\n\n#### 2.3 预览\u002F测试\n在开发本地调试的时候，我们可以使用一些工具来模拟服务器场景并实现热更新、热加载；即代码修改后自动编译构建，浏览器根据变化自动刷新同时还要方便我们查看源码。\n- 本地服务：WebServer \u002F Mock\n- 热加载\u002F热更新：Live Reloading \u002F HMR\n- 源码映射：Source Map\n\n\n#### 2.4 提交\n- Git Hooks：可在提交前进行代码质量和风格的检查\n- Lint-staged\n- 持续集成\n\n\n#### 2.5 部署\n- 自动化部署：CI\u002FCD \n- 自动化集成：Jenkins 可以调用执行脚本，集成自动化构建、打包、部署等\n\n\n## 3、常用的通用脚手架工具\n **vue-cli** —— 创建vue项目的工具\n **create-react-app** —— 创建react项目的工具\n **Yeoman** —— 用于创建自定义脚手架的工具\n **Plop** —— 用于项目中，重复创建相同类型的项目文件（例如vue中某个组件的js、css文件）\n\n\n## 4、常用的自动化构建工具\nGrunt\n- 插件完善\n- 构建速度慢（每一步都有临时文件读写，步骤越多）\n\nGulp\n- 插件完善\n- 构建速度更快（没有临时文件，基于内存实现）\n- 默认支持多个任务同时执行\n- 使用方式更直观易懂\n\nFis \n- 百度开源项目\n- 大而全的构建工具，集成度高一些\n\nWebpack\n- 准确说是模块打包工具，也可以完成自动化构建的功能\n\n## 5、开发阶段实践方案\n例如：我们要开发一个大型的vue项目，最基本的前端开发工程化需要如下工作：\n\n####5.1. 创建项目\n1. 自定义一个nodejs cli应用并发布到npm上（方法见后续文章）\n2. 使用nodejs cli应用创建一个项目，会生成源码目录结构、模板文件、公用文件、构建工具配置等，例如：package.json、webpack.config.js、eslint.lrc等\n3. 使用nodejs cli应用自动调用npm install等工作（可选）\n\n####5.2 编码\n1. 使用webpack进行构建，通过插件babel转换es6+、sass\u002Fless、vue模板代码等\n2. 使用webpack配合ES Modules\u002FCommJS规范进行模块化开发\n3. 使用eslint、stylelint进行代码规范检查\n4. 使用prettier进行代码格式化\n\n####5.3 预览\u002F测试\n1. 使用browser-sync、webpack-dev-server作为本地web服务，并进行热更新热加载\n2. 使用webpack配置的source map来调试源码\n3. 使用webpack配置的proxy、Nginx代理来解决跨域问题\n4. 使用mock模拟web服务器的http接口\n\n####5.4 提交\n1. 使用git + github做代码管理（其它gitee或者自己搭的仓库也可）\n2. 结合npm scripts、git hooks、lint-staged在提交代码前进行代码规范检查\n\n####5.5 部署\n1. 使用Jinkens调用命令行进行webpack打包，然后执行一系列后续操作\n2. 然后配合其它的工具可自动发布到我们需要的系统上去（根据公司需求可自定义）\n\n[特别鸣谢：拉勾教育前端高薪训练营](https:\u002F\u002Fkaiwu.lagou.com\u002F)\n","published_at":"2021-07-11T15:02:50.804Z","updated_at":"2021-07-12T07:15:26.316Z"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.aa04e74c.js" defer></script><script src="/assets/js/page--src-templates-blog-vue.a3da5a2e.js" defer></script>
  </body>
</html>
