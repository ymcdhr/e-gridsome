<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>首页 - Grdsome 博客</title><meta name="gridsome:hash" content="87002c5fa157b6e786d19711f6bffff4b0d9c799"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="96x96" href="/assets/static/favicon.b9532cc.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="76x76" href="/assets/static/favicon.f22e9f3.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="152x152" href="/assets/static/favicon.62d22cb.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="120x120" href="/assets/static/favicon.1539b60.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="167x167" href="/assets/static/favicon.dc0cdc5.9bb7ffafafc09ac851d81afb65b8ef59.png"><link data-vue-tag="ssr" rel="apple-touch-icon" type="image/png" sizes="180x180" href="/assets/static/favicon.7b22250.9bb7ffafafc09ac851d81afb65b8ef59.png"><link rel="preload" href="/assets/css/8.styles.8d7e1c32.css" as="style"><link rel="preload" href="/assets/js/app.aa04e74c.js" as="script"><link rel="preload" href="/assets/js/page--src-templates-blog-vue.a3da5a2e.js" as="script"><link rel="prefetch" href="/assets/js/page--node-modules-gridsome-app-pages-404-vue.0ddd1ab5.js"><link rel="prefetch" href="/assets/js/page--src-templates-blog-list-vue.8a24ccb4.js"><link rel="prefetch" href="/assets/js/page--src-templates-new-vue.8b4559ca.js"><link rel="prefetch" href="/assets/js/page--src-templates-project-list-vue.ba063837.js"><link rel="prefetch" href="/assets/js/page--src-templates-project-vue.7a542983.js"><link rel="prefetch" href="/assets/js/page--src-templates-social-vue.3a209dab.js"><link rel="stylesheet" href="/assets/css/8.styles.8d7e1c32.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <div id="app" data-server-rendered="true" class="layout"><header class="header" style="background-image:;"><div class="cover"></div><div class="user"><div class="el-image"><div class="el-image__placeholder"></div><!----></div><div class="name"></div><div class="description"></div></div></header><content class="content"><section class="el-container box is-vertical"><header class="el-header header" style="height:60px;"><div class="el-row"><div class="el-col el-col-24"><a><button type="button" class="el-button el-button--default"><!----><i class="el-icon-edit"></i><span>修改文章</span></button></a></div></div></header><section class="el-container cnt"><aside class="el-aside aside" style="width:200px;"><ul role="menubar" class="menu el-menu" style="background-color:;"><a href="/new?username=undefined"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-menu"></i><span>最新动态</span></li></a><a href="/blog-list"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-notebook-2"></i><span>博客列表</span></li></a><a href="/social"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-bangzhu"></i><span>关注账号</span></li></a><a href="/project-list"><li role="menuitem" tabindex="-1" class="el-menu-item" style="padding-left:20px;color:;background-color:;"><i class="el-icon-orange"></i><span>我的项目</span></li></a></ul></aside><main class="el-main main"><div class="article"><div class="markdown-title"><div class="title">
            前端工程化3：如何编写一个Nodejs Cli应用/自定义脚手架
        </div><div class="el-divider el-divider--horizontal"><!----></div><div class="time"><div class="updated">更新时间：2021/7/12</div><div class="published">发布时间：2021/7/11</div></div></div><div class="markdown-cnt"><!----><div class="cnt"><!----><div class="markdown-here-wrapper"><h2>什么是Nodejs Cli应用？</h2>
<p>简单来说就是在命令行可以使用nodejs来执行的应用，例如：vue-cli、creat-react-app、webpack-cli等；在前端开发过程中我们会用到很多的工具，这些工具在安装过后可以直接使用命令行执行；注意在全局安装和在项目安装不同。</p>
<pre><code>// 全局安装，直接执行命令
&gt; npm install webpack webpack-cli -g
&gt; webpack

// 项目安装，需要借助npx执行
&gt; npm install webpack webpack-cli --save-dev
&gt; npx webpack
</code></pre>
<h2>Nodejs Cli应用的工作流程！</h2>
<p><strong>1、启动过程：</strong></p>
<p>命令行执行命令 =&gt; 根据package.json中bin查询入口 =&gt; 执行入口js文件cli.js</p>
<p><strong>2、执行过程：</strong></p>
<p>命令行执行js文件功能启动=&gt; 命令行询问用户问题 =&gt; 结合问题答案+模板等文件 =&gt; 生成结构文件</p>
<h2>Nodejs Cli应用的入口文件：cli.js</h2>
<p><strong>1、入口文件路径</strong> ，首先在package.json 中添加bin字段</p>
<pre><code class="language-js">{
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;ncl&quot;</span>,
  <span class="hljs-string">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,
  <span class="hljs-string">&quot;bin&quot;</span>: {
    <span class="hljs-string">&quot;ncl&quot;</span>: <span class="hljs-string">&quot;./cli.js&quot;</span>   <span class="hljs-comment">//入口文件，ncl和name保持一致</span>
  },
  ...
}
</code></pre>
<p><strong>2、入口文件特定的文件头</strong> ，在cli.js顶部输入</p>
<pre><code class="language-js"><span class="hljs-meta">#!/usr/bin/env node</span>
</code></pre>
<p><strong>3、入口文件权限</strong>
// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755
// 具体就是通过 chmod 755 cli.js 实现修改</p>
<p><strong>4、简单测试模块</strong>
npm link 可以将模块链接到全局，也可以链接到使用该模块的项目node_modules中；这样在开发模块的过程中，不用发布到npm也可以使用模块进行测试。</p>
<pre><code class="language-js">&gt; npm link <span class="hljs-comment">// 在自定义模块项目的目录执行，将模块连接到全局</span>
&gt; ncl <span class="hljs-comment">// 直接执行模块，使用模块名</span>
</code></pre>
<h2>Nodejs Cli应用的示例</h2>
<p>该示例的功能实现一个自定义的脚手架：在命令行询问用户一些简单的问题作为参数，然后自动生成一些项目文件。其中的文件可以通过模板生成，也可以传递数据到模板。
<img src="/img/bVcS16g" alt="image.png"></p>
<p><strong>1、安装一些依赖模块</strong></p>
<pre><code class="language-js">&gt; npm install inquirer --save <span class="hljs-comment">//nodejs环境下，实现命令行的用户交互插件 </span>
&gt; npm install ejs --save <span class="hljs-comment">//模板引擎</span>
</code></pre>
<p><strong>2、cli.js中定义命令行询问用户问题</strong></p>
<ul>
<li>inquire.prompt进行命令行的用户询问操作</li>
<li>inquirer.prompt返回值为一个promise对象</li>
<li>inquirer.prompt的参数为一个数组</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;inquirer&#x27;</span>)

inquirer.<span class="hljs-title function_">prompt</span>([
    {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;input&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入项目名称?&#x27;</span>
    }
])
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">anwsers</span> =&gt;</span> {
    <span class="hljs-comment">// anwsers: { name: &quot;xxx&quot; } //anwsers返回一个结果对象</span>
})
</code></pre>
<p><strong>3、获取模板目录和目标生成目录</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)


<span class="hljs-comment">// 模板目录</span>
<span class="hljs-comment">// __dirname 获取当前执行代码文件的绝对路径</span>
<span class="hljs-comment">// tmplDir 为templates的绝对路径</span>
<span class="hljs-keyword">const</span> tmplDir = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;templates&#x27;</span>)

<span class="hljs-comment">// 目标目录</span>
<span class="hljs-comment">// process.cwd()返回 Node.js 进程的当前工作目录。</span>
<span class="hljs-comment">// process参考api文档：http://nodejs.cn/api/process.html</span>
<span class="hljs-keyword">const</span> destDir = process.<span class="hljs-title function_">cwd</span>()
</code></pre>
<p><strong>4、模板引擎渲染模板</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ejs&#x27;</span>)
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)

<span class="hljs-comment">// 通过模板引擎渲染文件</span>
<span class="hljs-comment">// 参数1：fileDir为文件的绝对路径</span>
<span class="hljs-comment">// 参数2：渲染模板所需变量，存在anwsers对象里面</span>
<span class="hljs-comment">// 参数3：回调函数，result为新文件</span>
ejs.<span class="hljs-title function_">renderFile</span>(fileDir, anwsers, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err

  <span class="hljs-comment">// 将结果写入目标文件路径</span>
  fs.<span class="hljs-title function_">writeFileSync</span>(fileDestDir, result)
})
</code></pre>
<pre><code>// 一个package.json作为模板的示例：
{
&quot;name&quot;: &quot;&lt;%= name %&gt;&quot;,
  &quot;version&quot;: &quot;&lt;%= version %&gt;&quot;,
  &quot;description&quot;: &quot;&lt;%= description %&gt;&quot;,
  &quot;author&quot;: &quot;&lt;%= author %&gt;&quot;,
  &quot;bin&quot;: &quot;cli.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre>
<p><strong>5、读取目录下的文件</strong></p>
<pre><code class="language-js">  <span class="hljs-comment">// 将模板下的文件全部转换到目标目录</span>
  <span class="hljs-comment">// 参数1：path</span>
  <span class="hljs-comment">// 参数2：回调函数，参数files为文件相对路径组成的数组</span>
  fs.<span class="hljs-title function_">readdir</span>(tmplDir, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err
    files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {
      <span class="hljs-comment">// 通过模板引擎渲染文件</span>
      <span class="hljs-comment">// 处理 file </span>
      })
    })
  })

</code></pre>
<p><strong>6、将文件写入路径</strong></p>
<pre><code class="language-js"><span class="hljs-comment">// 将结果写入目标文件路径</span>
<span class="hljs-comment">// 参数1：文件的绝对路径</span>
<span class="hljs-comment">// 参数2：文件内容</span>
fs.<span class="hljs-title function_">writeFileSync</span>(fileDestDir, result)
</code></pre>
<h2>模板文件相关</h2>
<p>这里是根据自己的需求将需要自动生成的文件放到模板目录下，没有变化的或者统一的文件就不需要使用模板引擎。
<strong>1、模板路径：templates；</strong></p>
<p><strong>2、通常将整理好的项目结构整体拷贝到templates下</strong>，例如：vue的示例源文件、lint文件、package.json等等；
<img src="/img/bVcS16h" alt="image.png"></p>
<h2>测试模块执行</h2>
<p>本地开发可以使用npm link关联模块目录和依赖此模块的项目node_modules目录；也可以发布到npm源上后直接安装使用模块。</p>
<p><strong>1、关联模块：</strong></p>
<pre><code class="language-bash">&gt; <span class="hljs-built_in">cd</span> nodejs-cli-sample //Nodejs Cli应用的目录
&gt; npm link // 将模块连接到全局
</code></pre>
<p><strong>2、执行模块：</strong></p>
<pre><code class="language-bash">&gt; <span class="hljs-built_in">cd</span> nodejs-cli-demo // 在项目目录执行模块
&gt; ncl // 直接执行模块，使用模块名（ncl 是项目nodejs-cli-sample的名称）
</code></pre>
<h2>发布Nodejs Cli应用</h2>
<p>1、可以直接使用npm publish发布到源上</p>
<pre><code class="language-bash">&gt; npm publish --registry=https://registry.xxxx
</code></pre>
<p>2、要考虑到npm源是否有写权限，可以发布到自己公司的npm源上或者yarn源上</p>
<pre><code>// 淘宝镜像源是只读的，publish不上去
// 发布到yarn的镜像源之后，使用淘宝镜像源时可以手动同步加快模块下载速度
yarn publish --registry https://registry.yarnpkg.com/
</code></pre>
<h2>完整示例代码</h2>
<p><strong>1、NodeJs Cli应用cli.js 入口文件</strong></p>
<pre><code class="language-js"><span class="hljs-meta">#!/usr/bin/env node</span>


<span class="hljs-comment">// Node CLI 应用入口文件必须要有这样的文件头</span>
<span class="hljs-comment">// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755</span>
<span class="hljs-comment">// 具体就是通过 chmod 755 cli.js 实现修改</span>

<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)    <span class="hljs-comment">// 文件读写</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)    <span class="hljs-comment">// 路径获取</span>
<span class="hljs-keyword">const</span> inquirer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;inquirer&#x27;</span>)    <span class="hljs-comment">//命令行用户交互</span>
<span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ejs&#x27;</span>)  <span class="hljs-comment">// 模板引擎</span>


<span class="hljs-comment">// 脚手架的工作过程：启动 =&gt; 命令行询问用户问题 =&gt; 结合问题答案+模板 =&gt; 生成结构文件</span>

inquirer.<span class="hljs-title function_">prompt</span>([
    {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;input&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入项目名称(\&#x27;\&#x27;)&#x27;</span>
    },
    {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;input&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;version&#x27;</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入项目版本号(1.0.0)&#x27;</span>
    },
    {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;input&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;description&#x27;</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入项目备注(\&#x27;\&#x27;)&#x27;</span>
    },
    {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;input&#x27;</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;author&#x27;</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;请输入作者名称(\&#x27;\&#x27;)&#x27;</span>
    }
])
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">anwsers</span> =&gt;</span> {
    <span class="hljs-comment">// anwsers: { name: &quot;xxx&quot; } //anwsers返回一个结果对象</span>

    <span class="hljs-comment">// 模板目录绝对路径</span>
    <span class="hljs-keyword">const</span> tmplDir = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;templates&#x27;</span>)
    <span class="hljs-comment">// 目标目录</span>
    <span class="hljs-keyword">const</span> destDir = process.<span class="hljs-title function_">cwd</span>()

    <span class="hljs-comment">// 读取目录下所有文件</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">readFiles</span> = (<span class="hljs-params">dir</span>) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>{
            <span class="hljs-comment">// 参数1：目录路径</span>
            <span class="hljs-comment">// 参数2：回调函数（错误对象，files为文件相对路径组成的数组）</span>
            fs.<span class="hljs-title function_">readdir</span>(dir, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> {
                <span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err)
                <span class="hljs-title function_">resolve</span>(files)
            })
        })
    }

    <span class="hljs-comment">// 处理模板文件</span>
    <span class="hljs-keyword">let</span> <span class="hljs-title function_">ejsRender</span> = (<span class="hljs-params">file</span>) =&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>{
            <span class="hljs-comment">// 模板文件绝对路径</span>
            <span class="hljs-keyword">let</span> dir = path.<span class="hljs-title function_">join</span>(tmplDir, file)
            <span class="hljs-comment">// 参数1：文件路径</span>
            <span class="hljs-comment">// 参数2：数据对象</span>
            <span class="hljs-comment">// 参数3：回调函数（错误对象，渲染后的新文件）</span>
            ejs.<span class="hljs-title function_">renderFile</span>(dir, anwsers, <span class="hljs-function">(<span class="hljs-params">err, result</span>) =&gt;</span> {
                <span class="hljs-keyword">if</span> (err) <span class="hljs-title function_">reject</span>(err)
                <span class="hljs-title function_">resolve</span>(result)
            })
        })
    }


    <span class="hljs-comment">// 1、先读取目录下所有文件</span>
    <span class="hljs-comment">// 2、使用ejs渲染所有模板</span>
    <span class="hljs-comment">// 3、再将新文件写到目标路径</span>
    <span class="hljs-title function_">readFiles</span>(tmplDir).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">files</span>)=&gt;</span>{
        files.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">file</span> =&gt;</span> {
            <span class="hljs-title function_">ejsRender</span>(file).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>{
                <span class="hljs-comment">// 目标文件绝对路径，file其实是文件相对路径</span>
                <span class="hljs-keyword">let</span> fileDestDir = path.<span class="hljs-title function_">join</span>(destDir, file)
                <span class="hljs-comment">// 将结果写入目标文件路径</span>
                <span class="hljs-comment">// 参数1：文件绝对路径</span>
                <span class="hljs-comment">// 参数2：渲染后新文件</span>
                fs.<span class="hljs-title function_">writeFileSync</span>(fileDestDir, result)
            },throwError)
        })

    },throwError)
})

<span class="hljs-comment">/**
 * 错误处理函数
 * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*错误对象</span>} error 
 */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">throwError</span>(<span class="hljs-params">error</span>){
    <span class="hljs-keyword">throw</span> error
}
</code></pre>
<p><strong>2、package.json 示例模板文件，使用的ejs模板引擎</strong></p>
<pre><code class="language-json"><span class="hljs-punctuation">{</span>
<span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;%= name %&gt;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;%= version %&gt;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;%= description %&gt;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;%= author %&gt;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;bin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cli.js&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span>
<span class="hljs-punctuation">}</span>

</code></pre>
<p><a href="https://kaiwu.lagou.com/">特别鸣谢：拉勾教育前端高薪训练营</a></p>
</div></div></div></div></main></section></section></content><footer class="footer"><div class="el-row el-row"><div class="el-col el-col-10"><div>
          © 2021 Tony Young  
          <a href="https://github.com/ymcdhr" target="_blank">Profile</a>  
          <a href="https://segmentfault.com/u/tonyyoung" target="_blank">Blog</a></div></div><div class="el-col el-col-4"><div style="text-align:center;font-size:12px;"><a href="" target="_blank">托泥羊技术有限公司</a>  
        </div></div><div class="el-col el-col-10"><div style="float:right;"><a href="https://developer.github.com" target="_blank">GitHub-API</a>  
        <a href="https://cn.vuejs.org/" target="_blank">Vue.js</a>  
        <a href="http://element.eleme.io/" target="_blank">Element</a></div></div></div></footer><!----></div>
    <script>window.__INITIAL_STATE__={"data":{"data":{"id":"10","title":"前端工程化3：如何编写一个Nodejs Cli应用\u002F自定义脚手架","user":{"id":1,"username":"ymcdhr","name":"Tony Young","image":{"url":"\u002Fuploads\u002Flogo_521b3eebb2.jpg"}},"content":"## 什么是Nodejs Cli应用？\n简单来说就是在命令行可以使用nodejs来执行的应用，例如：vue-cli、creat-react-app、webpack-cli等；在前端开发过程中我们会用到很多的工具，这些工具在安装过后可以直接使用命令行执行；注意在全局安装和在项目安装不同。\n```\n\u002F\u002F 全局安装，直接执行命令\n\u003E npm install webpack webpack-cli -g\n\u003E webpack\n\n\u002F\u002F 项目安装，需要借助npx执行\n\u003E npm install webpack webpack-cli --save-dev\n\u003E npx webpack\n```\n\n## Nodejs Cli应用的工作流程！\n\n**1、启动过程：**\n\n命令行执行命令 =\u003E 根据package.json中bin查询入口 =\u003E 执行入口js文件cli.js\n\n**2、执行过程：**\n\n命令行执行js文件功能启动=\u003E 命令行询问用户问题 =\u003E 结合问题答案+模板等文件 =\u003E 生成结构文件\n\n\n## Nodejs Cli应用的入口文件：cli.js\n\n **1、入口文件路径** ，首先在package.json 中添加bin字段\n```js\n{\n  \"name\": \"ncl\",\n  \"main\": \"index.js\",\n  \"bin\": {\n    \"ncl\": \".\u002Fcli.js\"   \u002F\u002F入口文件，ncl和name保持一致\n  },\n  ...\n}\n```\n\n **2、入口文件特定的文件头** ，在cli.js顶部输入\n```js\n#!\u002Fusr\u002Fbin\u002Fenv node\n```\n\n **3、入口文件权限** \n\u002F\u002F 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755\n\u002F\u002F 具体就是通过 chmod 755 cli.js 实现修改\n\n **4、简单测试模块** \nnpm link 可以将模块链接到全局，也可以链接到使用该模块的项目node_modules中；这样在开发模块的过程中，不用发布到npm也可以使用模块进行测试。\n```js\n\u003E npm link \u002F\u002F 在自定义模块项目的目录执行，将模块连接到全局\n\u003E ncl \u002F\u002F 直接执行模块，使用模块名\n```\n\n## Nodejs Cli应用的示例\n该示例的功能实现一个自定义的脚手架：在命令行询问用户一些简单的问题作为参数，然后自动生成一些项目文件。其中的文件可以通过模板生成，也可以传递数据到模板。\n![image.png](\u002Fimg\u002FbVcS16g)\n\n **1、安装一些依赖模块** \n```js\n\u003E npm install inquirer --save \u002F\u002Fnodejs环境下，实现命令行的用户交互插件 \n\u003E npm install ejs --save \u002F\u002F模板引擎\n```\n\n **2、cli.js中定义命令行询问用户问题**\n- inquire.prompt进行命令行的用户询问操作\n- inquirer.prompt返回值为一个promise对象\n- inquirer.prompt的参数为一个数组\n\n```js\nconst inquirer = require('inquirer')\n\ninquirer.prompt([\n    {\n        type: 'input',\n        name: 'name',\n        message: '请输入项目名称?'\n    }\n])\n.then(anwsers =\u003E {\n    \u002F\u002F anwsers: { name: \"xxx\" } \u002F\u002Fanwsers返回一个结果对象\n})\n```\n\n **3、获取模板目录和目标生成目录** \n\n```js\nconst path = require('path')\n\n\n\u002F\u002F 模板目录\n\u002F\u002F __dirname 获取当前执行代码文件的绝对路径\n\u002F\u002F tmplDir 为templates的绝对路径\nconst tmplDir = path.join(__dirname, 'templates')\n\n\u002F\u002F 目标目录\n\u002F\u002F process.cwd()返回 Node.js 进程的当前工作目录。\n\u002F\u002F process参考api文档：http:\u002F\u002Fnodejs.cn\u002Fapi\u002Fprocess.html\nconst destDir = process.cwd()\n```\n\n **4、模板引擎渲染模板** \n```js\nconst ejs = require('ejs')\nconst path = require('path')\n\n\u002F\u002F 通过模板引擎渲染文件\n\u002F\u002F 参数1：fileDir为文件的绝对路径\n\u002F\u002F 参数2：渲染模板所需变量，存在anwsers对象里面\n\u002F\u002F 参数3：回调函数，result为新文件\nejs.renderFile(fileDir, anwsers, (err, result) =\u003E {\n  if (err) throw err\n\n  \u002F\u002F 将结果写入目标文件路径\n  fs.writeFileSync(fileDestDir, result)\n})\n```\n```\n\u002F\u002F 一个package.json作为模板的示例：\n{\n\"name\": \"\u003C%= name %\u003E\",\n  \"version\": \"\u003C%= version %\u003E\",\n  \"description\": \"\u003C%= description %\u003E\",\n  \"author\": \"\u003C%= author %\u003E\",\n  \"bin\": \"cli.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"license\": \"ISC\"\n}\n\n```\n\n **5、读取目录下的文件** \n```js\n  \u002F\u002F 将模板下的文件全部转换到目标目录\n  \u002F\u002F 参数1：path\n  \u002F\u002F 参数2：回调函数，参数files为文件相对路径组成的数组\n  fs.readdir(tmplDir, (err, files) =\u003E {\n    if (err) throw err\n    files.forEach(file =\u003E {\n      \u002F\u002F 通过模板引擎渲染文件\n      \u002F\u002F 处理 file \n      })\n    })\n  })\n\n```\n\n **6、将文件写入路径** \n```js\n\u002F\u002F 将结果写入目标文件路径\n\u002F\u002F 参数1：文件的绝对路径\n\u002F\u002F 参数2：文件内容\nfs.writeFileSync(fileDestDir, result)\n```\n\n## 模板文件相关\n这里是根据自己的需求将需要自动生成的文件放到模板目录下，没有变化的或者统一的文件就不需要使用模板引擎。\n**1、模板路径：templates；**\n\n**2、通常将整理好的项目结构整体拷贝到templates下**，例如：vue的示例源文件、lint文件、package.json等等；\n![image.png](\u002Fimg\u002FbVcS16h)\n\n## 测试模块执行\n本地开发可以使用npm link关联模块目录和依赖此模块的项目node_modules目录；也可以发布到npm源上后直接安装使用模块。\n\n**1、关联模块：**\n```bash\n\u003E cd nodejs-cli-sample \u002F\u002FNodejs Cli应用的目录\n\u003E npm link \u002F\u002F 将模块连接到全局\n```\n\n**2、执行模块：**\n```bash\n\u003E cd nodejs-cli-demo \u002F\u002F 在项目目录执行模块\n\u003E ncl \u002F\u002F 直接执行模块，使用模块名（ncl 是项目nodejs-cli-sample的名称）\n```\n\n## 发布Nodejs Cli应用\n1、可以直接使用npm publish发布到源上\n```bash\n\u003E npm publish --registry=https:\u002F\u002Fregistry.xxxx\n```\n2、要考虑到npm源是否有写权限，可以发布到自己公司的npm源上或者yarn源上\n```\n\u002F\u002F 淘宝镜像源是只读的，publish不上去\n\u002F\u002F 发布到yarn的镜像源之后，使用淘宝镜像源时可以手动同步加快模块下载速度\nyarn publish --registry https:\u002F\u002Fregistry.yarnpkg.com\u002F\n```\n\n## 完整示例代码\n**1、NodeJs Cli应用cli.js 入口文件**\n```js\n#!\u002Fusr\u002Fbin\u002Fenv node\n\n\n\u002F\u002F Node CLI 应用入口文件必须要有这样的文件头\n\u002F\u002F 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755\n\u002F\u002F 具体就是通过 chmod 755 cli.js 实现修改\n\nconst fs = require('fs')    \u002F\u002F 文件读写\nconst path = require('path')    \u002F\u002F 路径获取\nconst inquirer = require('inquirer')    \u002F\u002F命令行用户交互\nconst ejs = require('ejs')  \u002F\u002F 模板引擎\n\n\n\u002F\u002F 脚手架的工作过程：启动 =\u003E 命令行询问用户问题 =\u003E 结合问题答案+模板 =\u003E 生成结构文件\n\ninquirer.prompt([\n    {\n        type: 'input',\n        name: 'name',\n        message: '请输入项目名称(\\'\\')'\n    },\n    {\n        type: 'input',\n        name: 'version',\n        message: '请输入项目版本号(1.0.0)'\n    },\n    {\n        type: 'input',\n        name: 'description',\n        message: '请输入项目备注(\\'\\')'\n    },\n    {\n        type: 'input',\n        name: 'author',\n        message: '请输入作者名称(\\'\\')'\n    }\n])\n.then(anwsers =\u003E {\n    \u002F\u002F anwsers: { name: \"xxx\" } \u002F\u002Fanwsers返回一个结果对象\n\n    \u002F\u002F 模板目录绝对路径\n    const tmplDir = path.join(__dirname, 'templates')\n    \u002F\u002F 目标目录\n    const destDir = process.cwd()\n\n    \u002F\u002F 读取目录下所有文件\n    let readFiles = (dir) =\u003E {\n        return new Promise((resolve, reject)=\u003E{\n            \u002F\u002F 参数1：目录路径\n            \u002F\u002F 参数2：回调函数（错误对象，files为文件相对路径组成的数组）\n            fs.readdir(dir, (err, files) =\u003E {\n                if (err) reject(err)\n                resolve(files)\n            })\n        })\n    }\n\n    \u002F\u002F 处理模板文件\n    let ejsRender = (file) =\u003E {\n        return new Promise((resolve, reject)=\u003E{\n            \u002F\u002F 模板文件绝对路径\n            let dir = path.join(tmplDir, file)\n            \u002F\u002F 参数1：文件路径\n            \u002F\u002F 参数2：数据对象\n            \u002F\u002F 参数3：回调函数（错误对象，渲染后的新文件）\n            ejs.renderFile(dir, anwsers, (err, result) =\u003E {\n                if (err) reject(err)\n                resolve(result)\n            })\n        })\n    }\n\n\n    \u002F\u002F 1、先读取目录下所有文件\n    \u002F\u002F 2、使用ejs渲染所有模板\n    \u002F\u002F 3、再将新文件写到目标路径\n    readFiles(tmplDir).then((files)=\u003E{\n        files.forEach(file =\u003E {\n            ejsRender(file).then((result)=\u003E{\n                \u002F\u002F 目标文件绝对路径，file其实是文件相对路径\n                let fileDestDir = path.join(destDir, file)\n                \u002F\u002F 将结果写入目标文件路径\n                \u002F\u002F 参数1：文件绝对路径\n                \u002F\u002F 参数2：渲染后新文件\n                fs.writeFileSync(fileDestDir, result)\n            },throwError)\n        })\n\n    },throwError)\n})\n\n\u002F**\n * 错误处理函数\n * @param {*错误对象} error \n *\u002F\nfunction throwError(error){\n    throw error\n}\n```\n\n**2、package.json 示例模板文件，使用的ejs模板引擎**\n```json\n{\n\"name\": \"\u003C%= name %\u003E\",\n  \"version\": \"\u003C%= version %\u003E\",\n  \"description\": \"\u003C%= description %\u003E\",\n  \"author\": \"\u003C%= author %\u003E\",\n  \"bin\": \"cli.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"license\": \"ISC\"\n}\n\n```\n\n[特别鸣谢：拉勾教育前端高薪训练营](https:\u002F\u002Fkaiwu.lagou.com\u002F)\n","published_at":"2021-07-11T15:03:08.830Z","updated_at":"2021-07-12T07:15:26.316Z"}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.aa04e74c.js" defer></script><script src="/assets/js/page--src-templates-blog-vue.a3da5a2e.js" defer></script>
  </body>
</html>
